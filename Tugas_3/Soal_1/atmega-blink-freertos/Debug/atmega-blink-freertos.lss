
atmega-blink-freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  0000251c  000025b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000251c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000135  0080015e  0080015e  0000260e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000260e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002640  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c8  00000000  00000000  00002680  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ce5f  00000000  00000000  00002d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002661  00000000  00000000  0000fba7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004592  00000000  00000000  00012208  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000014c0  00000000  00000000  0001679c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000038f0  00000000  00000000  00017c5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007e10  00000000  00000000  0001b54c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000668  00000000  00000000  0002335c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 67 00 	jmp	0xce	; 0xce <__ctors_end>
       4:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
       8:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
       c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      10:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      14:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      18:	0c 94 a4 0e 	jmp	0x1d48	; 0x1d48 <__vector_6>
      1c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      20:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      24:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      28:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      2c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      30:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      34:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      38:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      3c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      40:	0c 94 8b 04 	jmp	0x916	; 0x916 <__vector_16>
      44:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      48:	0c 94 f9 02 	jmp	0x5f2	; 0x5f2 <__vector_18>
      4c:	0c 94 2b 03 	jmp	0x656	; 0x656 <__vector_19>
      50:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      54:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      58:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      5c:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      60:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      64:	0c 94 8f 00 	jmp	0x11e	; 0x11e <__bad_interrupt>
      68:	79 0c       	add	r7, r9
      6a:	79 0c       	add	r7, r9
      6c:	79 0c       	add	r7, r9
      6e:	b8 0c       	add	r11, r8
      70:	a3 0c       	add	r10, r3
      72:	b2 0c       	add	r11, r2
      74:	79 0c       	add	r7, r9
      76:	79 0c       	add	r7, r9
      78:	b8 0c       	add	r11, r8
      7a:	a3 0c       	add	r10, r3

0000007c <__trampolines_end>:
      7c:	00 00       	nop
      7e:	00 08       	sbc	r0, r0
      80:	00 02       	muls	r16, r16
      82:	01 00       	.word	0x0001	; ????
      84:	00 03       	mulsu	r16, r16
      86:	04 07       	cpc	r16, r20
	...

00000090 <digital_pin_to_bit_mask_PGM>:
      90:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      a0:	04 08 10 20                                         ... 

000000a4 <digital_pin_to_port_PGM>:
      a4:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      b4:	03 03 03 03                                         ....

000000b8 <port_to_output_PGM>:
      b8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000c2 <port_to_mode_PGM>:
      c2:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000cc <__ctors_start>:
      cc:	5b 03       	fmul	r21, r19

000000ce <__ctors_end>:
      ce:	11 24       	eor	r1, r1
      d0:	1f be       	out	0x3f, r1	; 63
      d2:	cf ef       	ldi	r28, 0xFF	; 255
      d4:	d8 e0       	ldi	r29, 0x08	; 8
      d6:	de bf       	out	0x3e, r29	; 62
      d8:	cd bf       	out	0x3d, r28	; 61

000000da <__do_copy_data>:
      da:	11 e0       	ldi	r17, 0x01	; 1
      dc:	a0 e0       	ldi	r26, 0x00	; 0
      de:	b1 e0       	ldi	r27, 0x01	; 1
      e0:	ec e1       	ldi	r30, 0x1C	; 28
      e2:	f5 e2       	ldi	r31, 0x25	; 37
      e4:	02 c0       	rjmp	.+4      	; 0xea <__do_copy_data+0x10>
      e6:	05 90       	lpm	r0, Z+
      e8:	0d 92       	st	X+, r0
      ea:	ae 35       	cpi	r26, 0x5E	; 94
      ec:	b1 07       	cpc	r27, r17
      ee:	d9 f7       	brne	.-10     	; 0xe6 <__do_copy_data+0xc>

000000f0 <__do_clear_bss>:
      f0:	22 e0       	ldi	r18, 0x02	; 2
      f2:	ae e5       	ldi	r26, 0x5E	; 94
      f4:	b1 e0       	ldi	r27, 0x01	; 1
      f6:	01 c0       	rjmp	.+2      	; 0xfa <.do_clear_bss_start>

000000f8 <.do_clear_bss_loop>:
      f8:	1d 92       	st	X+, r1

000000fa <.do_clear_bss_start>:
      fa:	a3 39       	cpi	r26, 0x93	; 147
      fc:	b2 07       	cpc	r27, r18
      fe:	e1 f7       	brne	.-8      	; 0xf8 <.do_clear_bss_loop>

00000100 <__do_global_ctors>:
     100:	10 e0       	ldi	r17, 0x00	; 0
     102:	c7 e6       	ldi	r28, 0x67	; 103
     104:	d0 e0       	ldi	r29, 0x00	; 0
     106:	04 c0       	rjmp	.+8      	; 0x110 <__do_global_ctors+0x10>
     108:	21 97       	sbiw	r28, 0x01	; 1
     10a:	fe 01       	movw	r30, r28
     10c:	0e 94 55 11 	call	0x22aa	; 0x22aa <__tablejump2__>
     110:	c6 36       	cpi	r28, 0x66	; 102
     112:	d1 07       	cpc	r29, r17
     114:	c9 f7       	brne	.-14     	; 0x108 <__do_global_ctors+0x8>
     116:	0e 94 88 03 	call	0x710	; 0x710 <main>
     11a:	0c 94 8c 12 	jmp	0x2518	; 0x2518 <_exit>

0000011e <__bad_interrupt>:
     11e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000122 <_ZN14HardwareSerial5beginEm>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     122:	cf 93       	push	r28
     124:	df 93       	push	r29
     126:	00 d0       	rcall	.+0      	; 0x128 <_ZN14HardwareSerial5beginEm+0x6>
     128:	00 d0       	rcall	.+0      	; 0x12a <_ZN14HardwareSerial5beginEm+0x8>
     12a:	00 d0       	rcall	.+0      	; 0x12c <_ZN14HardwareSerial5beginEm+0xa>
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62
     130:	9a 83       	std	Y+2, r25	; 0x02
     132:	89 83       	std	Y+1, r24	; 0x01
     134:	4b 83       	std	Y+3, r20	; 0x03
     136:	5c 83       	std	Y+4, r21	; 0x04
     138:	6d 83       	std	Y+5, r22	; 0x05
     13a:	7e 83       	std	Y+6, r23	; 0x06
     13c:	8b 81       	ldd	r24, Y+3	; 0x03
     13e:	9c 81       	ldd	r25, Y+4	; 0x04
     140:	ad 81       	ldd	r26, Y+5	; 0x05
     142:	be 81       	ldd	r27, Y+6	; 0x06
     144:	e9 81       	ldd	r30, Y+1	; 0x01
     146:	fa 81       	ldd	r31, Y+2	; 0x02
     148:	26 e0       	ldi	r18, 0x06	; 6
     14a:	ac 01       	movw	r20, r24
     14c:	bd 01       	movw	r22, r26
     14e:	cf 01       	movw	r24, r30
     150:	0e 94 94 02 	call	0x528	; 0x528 <_ZN14HardwareSerial5beginEmh>
     154:	00 00       	nop
     156:	26 96       	adiw	r28, 0x06	; 6
     158:	0f b6       	in	r0, 0x3f	; 63
     15a:	f8 94       	cli
     15c:	de bf       	out	0x3e, r29	; 62
     15e:	0f be       	out	0x3f, r0	; 63
     160:	cd bf       	out	0x3d, r28	; 61
     162:	df 91       	pop	r29
     164:	cf 91       	pop	r28
     166:	08 95       	ret

00000168 <setup>:
// task handle diperlukan jika ingin mengakses parameter suatu task. optional
TaskHandle_t xHandle1 = NULL;
TaskHandle_t xHandle2 = NULL;
TaskHandle_t xHandle3 = NULL;

void setup() {
     168:	ef 92       	push	r14
     16a:	ff 92       	push	r15
     16c:	0f 93       	push	r16
     16e:	cf 93       	push	r28
     170:	df 93       	push	r29
     172:	cd b7       	in	r28, 0x3d	; 61
     174:	de b7       	in	r29, 0x3e	; 62
  Serial.begin(115200);
     176:	40 e0       	ldi	r20, 0x00	; 0
     178:	52 ec       	ldi	r21, 0xC2	; 194
     17a:	61 e0       	ldi	r22, 0x01	; 1
     17c:	70 e0       	ldi	r23, 0x00	; 0
     17e:	86 e6       	ldi	r24, 0x66	; 102
     180:	91 e0       	ldi	r25, 0x01	; 1
     182:	0e 94 91 00 	call	0x122	; 0x122 <_ZN14HardwareSerial5beginEm>
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED1, OUTPUT);
     186:	61 e0       	ldi	r22, 0x01	; 1
     188:	82 e0       	ldi	r24, 0x02	; 2
     18a:	0e 94 9a 05 	call	0xb34	; 0xb34 <pinMode>
  pinMode(LED2, OUTPUT);
     18e:	61 e0       	ldi	r22, 0x01	; 1
     190:	83 e0       	ldi	r24, 0x03	; 3
     192:	0e 94 9a 05 	call	0xb34	; 0xb34 <pinMode>
  pinMode(LED3, OUTPUT);
     196:	61 e0       	ldi	r22, 0x01	; 1
     198:	84 e0       	ldi	r24, 0x04	; 4
     19a:	0e 94 9a 05 	call	0xb34	; 0xb34 <pinMode>
  pinMode(LED_BUILTIN, OUTPUT);
     19e:	61 e0       	ldi	r22, 0x01	; 1
     1a0:	8d e0       	ldi	r24, 0x0D	; 13
     1a2:	0e 94 9a 05 	call	0xb34	; 0xb34 <pinMode>
    TaskBlinkLED1
    ,  "TaskBlinkLED1"  // A name just for humans
    ,  100  // This stack size can be checked & adjusted by reading the Stack Highwater
    ,  NULL
    ,  2  // Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.
    ,  &xHandle1 );
     1a6:	0f 2e       	mov	r0, r31
     1a8:	fe e5       	ldi	r31, 0x5E	; 94
     1aa:	ef 2e       	mov	r14, r31
     1ac:	f1 e0       	ldi	r31, 0x01	; 1
     1ae:	ff 2e       	mov	r15, r31
     1b0:	f0 2d       	mov	r31, r0
     1b2:	02 e0       	ldi	r16, 0x02	; 2
     1b4:	20 e0       	ldi	r18, 0x00	; 0
     1b6:	30 e0       	ldi	r19, 0x00	; 0
     1b8:	44 e6       	ldi	r20, 0x64	; 100
     1ba:	50 e0       	ldi	r21, 0x00	; 0
     1bc:	66 e0       	ldi	r22, 0x06	; 6
     1be:	71 e0       	ldi	r23, 0x01	; 1
     1c0:	84 e3       	ldi	r24, 0x34	; 52
     1c2:	91 e0       	ldi	r25, 0x01	; 1
     1c4:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskCreate>
    TaskBlinkLED2
    ,  "TaskBlinkLED2"  // A name just for humans
    ,  100  // This stack size can be checked & adjusted by reading the Stack Highwater
    ,  NULL
    ,  2  // Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.
    ,  &xHandle2 );
     1c8:	0f 2e       	mov	r0, r31
     1ca:	f0 e6       	ldi	r31, 0x60	; 96
     1cc:	ef 2e       	mov	r14, r31
     1ce:	f1 e0       	ldi	r31, 0x01	; 1
     1d0:	ff 2e       	mov	r15, r31
     1d2:	f0 2d       	mov	r31, r0
     1d4:	02 e0       	ldi	r16, 0x02	; 2
     1d6:	20 e0       	ldi	r18, 0x00	; 0
     1d8:	30 e0       	ldi	r19, 0x00	; 0
     1da:	44 e6       	ldi	r20, 0x64	; 100
     1dc:	50 e0       	ldi	r21, 0x00	; 0
     1de:	64 e1       	ldi	r22, 0x14	; 20
     1e0:	71 e0       	ldi	r23, 0x01	; 1
     1e2:	80 e6       	ldi	r24, 0x60	; 96
     1e4:	91 e0       	ldi	r25, 0x01	; 1
     1e6:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskCreate>
    TaskBlinkLED3
    ,  "TaskBlinkLED3"  // A name just for humans
    ,  100  // This stack size can be checked & adjusted by reading the Stack Highwater
    ,  NULL
    ,  2  // Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.
    ,  &xHandle3  );
     1ea:	0f 2e       	mov	r0, r31
     1ec:	f2 e6       	ldi	r31, 0x62	; 98
     1ee:	ef 2e       	mov	r14, r31
     1f0:	f1 e0       	ldi	r31, 0x01	; 1
     1f2:	ff 2e       	mov	r15, r31
     1f4:	f0 2d       	mov	r31, r0
     1f6:	02 e0       	ldi	r16, 0x02	; 2
     1f8:	20 e0       	ldi	r18, 0x00	; 0
     1fa:	30 e0       	ldi	r19, 0x00	; 0
     1fc:	44 e6       	ldi	r20, 0x64	; 100
     1fe:	50 e0       	ldi	r21, 0x00	; 0
     200:	62 e2       	ldi	r22, 0x22	; 34
     202:	71 e0       	ldi	r23, 0x01	; 1
     204:	8c e8       	ldi	r24, 0x8C	; 140
     206:	91 e0       	ldi	r25, 0x01	; 1
     208:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskCreate>
}
     20c:	00 00       	nop
     20e:	df 91       	pop	r29
     210:	cf 91       	pop	r28
     212:	0f 91       	pop	r16
     214:	ff 90       	pop	r15
     216:	ef 90       	pop	r14
     218:	08 95       	ret

0000021a <loop>:

// menunjukkan loop dapat tetap dijalankan terpisah dari semua task FreeRTOS
void loop() {
     21a:	cf 93       	push	r28
     21c:	df 93       	push	r29
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
  static int counter=0;
  // UBaseType_t uxHighWaterMark;
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
     222:	61 e0       	ldi	r22, 0x01	; 1
     224:	8d e0       	ldi	r24, 0x0D	; 13
     226:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
  delay(1000);                       // wait for a second
     22a:	68 ee       	ldi	r22, 0xE8	; 232
     22c:	73 e0       	ldi	r23, 0x03	; 3
     22e:	80 e0       	ldi	r24, 0x00	; 0
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <delay>
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
     236:	60 e0       	ldi	r22, 0x00	; 0
     238:	8d e0       	ldi	r24, 0x0D	; 13
     23a:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
  delay(1000);                       // wait for a second
     23e:	68 ee       	ldi	r22, 0xE8	; 232
     240:	73 e0       	ldi	r23, 0x03	; 3
     242:	80 e0       	ldi	r24, 0x00	; 0
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <delay>
  Serial.println(counter);
     24a:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <_ZZ4loopE7counter>
     24e:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <_ZZ4loopE7counter+0x1>
     252:	4a e0       	ldi	r20, 0x0A	; 10
     254:	50 e0       	ldi	r21, 0x00	; 0
     256:	bc 01       	movw	r22, r24
     258:	86 e6       	ldi	r24, 0x66	; 102
     25a:	91 e0       	ldi	r25, 0x01	; 1
     25c:	0e 94 79 04 	call	0x8f2	; 0x8f2 <_ZN5Print7printlnEii>
}
     260:	00 00       	nop
     262:	df 91       	pop	r29
     264:	cf 91       	pop	r28
     266:	08 95       	ret

00000268 <_ZL13TaskBlinkLED1Pv>:

static void TaskBlinkLED1(void *pvParameters) // Main Red LED Flash
{
     268:	cf 93       	push	r28
     26a:	df 93       	push	r29
     26c:	00 d0       	rcall	.+0      	; 0x26e <_ZL13TaskBlinkLED1Pv+0x6>
     26e:	00 d0       	rcall	.+0      	; 0x270 <_ZL13TaskBlinkLED1Pv+0x8>
     270:	1f 92       	push	r1
     272:	cd b7       	in	r28, 0x3d	; 61
     274:	de b7       	in	r29, 0x3e	; 62
     276:	9d 83       	std	Y+5, r25	; 0x05
     278:	8c 83       	std	Y+4, r24	; 0x04
  UBaseType_t uxHighWaterMark;
  uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
     27a:	80 e0       	ldi	r24, 0x00	; 0
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <uxTaskGetStackHighWaterMark>
     282:	89 83       	std	Y+1, r24	; 0x01
  TickType_t xLastWakeTime;
  /* The xLastWakeTime variable needs to be initialised with the current tick
    count.  Note that this is the only time we access this variable.  From this
    point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
    API function. */
  xLastWakeTime = xTaskGetTickCount();
     284:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <xTaskGetTickCount>
     288:	9b 83       	std	Y+3, r25	; 0x03
     28a:	8a 83       	std	Y+2, r24	; 0x02
  while (1)
  {
    digitalWrite(LED1, HIGH);
     28c:	61 e0       	ldi	r22, 0x01	; 1
     28e:	82 e0       	ldi	r24, 0x02	; 2
     290:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
    vTaskDelayUntil( &xLastWakeTime, ( 10 / portTICK_PERIOD_MS ) );
     294:	ce 01       	movw	r24, r28
     296:	02 96       	adiw	r24, 0x02	; 2
     298:	60 e0       	ldi	r22, 0x00	; 0
     29a:	70 e0       	ldi	r23, 0x00	; 0
     29c:	0e 94 18 09 	call	0x1230	; 0x1230 <vTaskDelayUntil>
    digitalWrite(LED1, LOW);
     2a0:	60 e0       	ldi	r22, 0x00	; 0
     2a2:	82 e0       	ldi	r24, 0x02	; 2
     2a4:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
    vTaskDelayUntil( &xLastWakeTime, ( 10 / portTICK_PERIOD_MS ) );
     2a8:	ce 01       	movw	r24, r28
     2aa:	02 96       	adiw	r24, 0x02	; 2
     2ac:	60 e0       	ldi	r22, 0x00	; 0
     2ae:	70 e0       	ldi	r23, 0x00	; 0
     2b0:	0e 94 18 09 	call	0x1230	; 0x1230 <vTaskDelayUntil>
	uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
     2b4:	80 e0       	ldi	r24, 0x00	; 0
     2b6:	90 e0       	ldi	r25, 0x00	; 0
     2b8:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <uxTaskGetStackHighWaterMark>
     2bc:	89 83       	std	Y+1, r24	; 0x01
  /* The xLastWakeTime variable needs to be initialised with the current tick
    count.  Note that this is the only time we access this variable.  From this
    point on xLastWakeTime is managed automatically by the vTaskDelayUntil()
    API function. */
  xLastWakeTime = xTaskGetTickCount();
  while (1)
     2be:	e6 cf       	rjmp	.-52     	; 0x28c <_ZL13TaskBlinkLED1Pv+0x24>

000002c0 <_ZL13TaskBlinkLED2Pv>:
	uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
  }
}

static void TaskBlinkLED2(void *pvParameters) // Main Red LED Flash
{
     2c0:	cf 93       	push	r28
     2c2:	df 93       	push	r29
     2c4:	00 d0       	rcall	.+0      	; 0x2c6 <_ZL13TaskBlinkLED2Pv+0x6>
     2c6:	00 d0       	rcall	.+0      	; 0x2c8 <_ZL13TaskBlinkLED2Pv+0x8>
     2c8:	1f 92       	push	r1
     2ca:	cd b7       	in	r28, 0x3d	; 61
     2cc:	de b7       	in	r29, 0x3e	; 62
     2ce:	9d 83       	std	Y+5, r25	; 0x05
     2d0:	8c 83       	std	Y+4, r24	; 0x04
  UBaseType_t uxHighWaterMark;
  uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
     2d2:	80 e0       	ldi	r24, 0x00	; 0
     2d4:	90 e0       	ldi	r25, 0x00	; 0
     2d6:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <uxTaskGetStackHighWaterMark>
     2da:	89 83       	std	Y+1, r24	; 0x01
  TickType_t xLastWakeTime;
  xLastWakeTime = xTaskGetTickCount();
     2dc:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <xTaskGetTickCount>
     2e0:	9b 83       	std	Y+3, r25	; 0x03
     2e2:	8a 83       	std	Y+2, r24	; 0x02
  while (1)
  {
    digitalWrite(LED2, HIGH);
     2e4:	61 e0       	ldi	r22, 0x01	; 1
     2e6:	83 e0       	ldi	r24, 0x03	; 3
     2e8:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
    vTaskDelayUntil( &xLastWakeTime, ( 15 / portTICK_PERIOD_MS ) );
     2ec:	ce 01       	movw	r24, r28
     2ee:	02 96       	adiw	r24, 0x02	; 2
     2f0:	60 e0       	ldi	r22, 0x00	; 0
     2f2:	70 e0       	ldi	r23, 0x00	; 0
     2f4:	0e 94 18 09 	call	0x1230	; 0x1230 <vTaskDelayUntil>
    digitalWrite(LED2, LOW);
     2f8:	60 e0       	ldi	r22, 0x00	; 0
     2fa:	83 e0       	ldi	r24, 0x03	; 3
     2fc:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
    vTaskDelayUntil( &xLastWakeTime, ( 15 / portTICK_PERIOD_MS ) );
     300:	ce 01       	movw	r24, r28
     302:	02 96       	adiw	r24, 0x02	; 2
     304:	60 e0       	ldi	r22, 0x00	; 0
     306:	70 e0       	ldi	r23, 0x00	; 0
     308:	0e 94 18 09 	call	0x1230	; 0x1230 <vTaskDelayUntil>
	uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <uxTaskGetStackHighWaterMark>
     314:	89 83       	std	Y+1, r24	; 0x01
{
  UBaseType_t uxHighWaterMark;
  uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
  TickType_t xLastWakeTime;
  xLastWakeTime = xTaskGetTickCount();
  while (1)
     316:	e6 cf       	rjmp	.-52     	; 0x2e4 <_ZL13TaskBlinkLED2Pv+0x24>

00000318 <_ZL13TaskBlinkLED3Pv>:
	uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
  }
}

static void TaskBlinkLED3(void *pvParameters) // Main Red LED Flash
{
     318:	cf 93       	push	r28
     31a:	df 93       	push	r29
     31c:	00 d0       	rcall	.+0      	; 0x31e <_ZL13TaskBlinkLED3Pv+0x6>
     31e:	00 d0       	rcall	.+0      	; 0x320 <_ZL13TaskBlinkLED3Pv+0x8>
     320:	1f 92       	push	r1
     322:	cd b7       	in	r28, 0x3d	; 61
     324:	de b7       	in	r29, 0x3e	; 62
     326:	9d 83       	std	Y+5, r25	; 0x05
     328:	8c 83       	std	Y+4, r24	; 0x04
  UBaseType_t uxHighWaterMark;
  uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
     32a:	80 e0       	ldi	r24, 0x00	; 0
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <uxTaskGetStackHighWaterMark>
     332:	89 83       	std	Y+1, r24	; 0x01
  TickType_t xLastWakeTime;
  xLastWakeTime = xTaskGetTickCount();
     334:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <xTaskGetTickCount>
     338:	9b 83       	std	Y+3, r25	; 0x03
     33a:	8a 83       	std	Y+2, r24	; 0x02
  while (1)
  {
    digitalWrite(LED3, HIGH);
     33c:	61 e0       	ldi	r22, 0x01	; 1
     33e:	84 e0       	ldi	r24, 0x04	; 4
     340:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
    vTaskDelayUntil( &xLastWakeTime, ( 25 / portTICK_PERIOD_MS ) );
     344:	ce 01       	movw	r24, r28
     346:	02 96       	adiw	r24, 0x02	; 2
     348:	61 e0       	ldi	r22, 0x01	; 1
     34a:	70 e0       	ldi	r23, 0x00	; 0
     34c:	0e 94 18 09 	call	0x1230	; 0x1230 <vTaskDelayUntil>
    digitalWrite(LED3, LOW);
     350:	60 e0       	ldi	r22, 0x00	; 0
     352:	84 e0       	ldi	r24, 0x04	; 4
     354:	0e 94 d6 05 	call	0xbac	; 0xbac <digitalWrite>
    vTaskDelayUntil( &xLastWakeTime, ( 25 / portTICK_PERIOD_MS ) );
     358:	ce 01       	movw	r24, r28
     35a:	02 96       	adiw	r24, 0x02	; 2
     35c:	61 e0       	ldi	r22, 0x01	; 1
     35e:	70 e0       	ldi	r23, 0x00	; 0
     360:	0e 94 18 09 	call	0x1230	; 0x1230 <vTaskDelayUntil>
	uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
     364:	80 e0       	ldi	r24, 0x00	; 0
     366:	90 e0       	ldi	r25, 0x00	; 0
     368:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <uxTaskGetStackHighWaterMark>
     36c:	89 83       	std	Y+1, r24	; 0x01
{
  UBaseType_t uxHighWaterMark;
  uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );
  TickType_t xLastWakeTime;
  xLastWakeTime = xTaskGetTickCount();
  while (1)
     36e:	e6 cf       	rjmp	.-52     	; 0x33c <_ZL13TaskBlinkLED3Pv+0x24>

00000370 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     370:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     372:	91 8d       	ldd	r25, Z+25	; 0x19
     374:	22 8d       	ldd	r18, Z+26	; 0x1a
     376:	89 2f       	mov	r24, r25
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	80 5c       	subi	r24, 0xC0	; 192
     37c:	9f 4f       	sbci	r25, 0xFF	; 255
     37e:	82 1b       	sub	r24, r18
     380:	91 09       	sbc	r25, r1
}
     382:	8f 73       	andi	r24, 0x3F	; 63
     384:	99 27       	eor	r25, r25
     386:	08 95       	ret

00000388 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     388:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     38a:	91 8d       	ldd	r25, Z+25	; 0x19
     38c:	82 8d       	ldd	r24, Z+26	; 0x1a
     38e:	98 17       	cp	r25, r24
     390:	31 f0       	breq	.+12     	; 0x39e <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     392:	82 8d       	ldd	r24, Z+26	; 0x1a
     394:	e8 0f       	add	r30, r24
     396:	f1 1d       	adc	r31, r1
     398:	85 8d       	ldd	r24, Z+29	; 0x1d
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     39e:	8f ef       	ldi	r24, 0xFF	; 255
     3a0:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     3a2:	08 95       	ret

000003a4 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     3a4:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     3a6:	91 8d       	ldd	r25, Z+25	; 0x19
     3a8:	82 8d       	ldd	r24, Z+26	; 0x1a
     3aa:	98 17       	cp	r25, r24
     3ac:	61 f0       	breq	.+24     	; 0x3c6 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     3ae:	82 8d       	ldd	r24, Z+26	; 0x1a
     3b0:	df 01       	movw	r26, r30
     3b2:	a8 0f       	add	r26, r24
     3b4:	b1 1d       	adc	r27, r1
     3b6:	5d 96       	adiw	r26, 0x1d	; 29
     3b8:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     3ba:	92 8d       	ldd	r25, Z+26	; 0x1a
     3bc:	9f 5f       	subi	r25, 0xFF	; 255
     3be:	9f 73       	andi	r25, 0x3F	; 63
     3c0:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     3ca:	08 95       	ret

000003cc <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     3cc:	fc 01       	movw	r30, r24
     3ce:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
     3d0:	44 8d       	ldd	r20, Z+28	; 0x1c
     3d2:	25 2f       	mov	r18, r21
     3d4:	30 e0       	ldi	r19, 0x00	; 0
     3d6:	84 2f       	mov	r24, r20
     3d8:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     3da:	82 1b       	sub	r24, r18
     3dc:	93 0b       	sbc	r25, r19
     3de:	54 17       	cp	r21, r20
     3e0:	10 f0       	brcs	.+4      	; 0x3e6 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
     3e2:	cf 96       	adiw	r24, 0x3f	; 63
     3e4:	08 95       	ret
  return tail - head - 1;
     3e6:	01 97       	sbiw	r24, 0x01	; 1
}
     3e8:	08 95       	ret

000003ea <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     3ea:	81 e5       	ldi	r24, 0x51	; 81
     3ec:	93 e0       	ldi	r25, 0x03	; 3
     3ee:	89 2b       	or	r24, r25
     3f0:	49 f0       	breq	.+18     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	89 2b       	or	r24, r25
     3f8:	29 f0       	breq	.+10     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     3fa:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_Z17Serial0_availablev>
     3fe:	81 11       	cpse	r24, r1
     400:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     404:	08 95       	ret

00000406 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     406:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     408:	84 8d       	ldd	r24, Z+28	; 0x1c
     40a:	df 01       	movw	r26, r30
     40c:	a8 0f       	add	r26, r24
     40e:	b1 1d       	adc	r27, r1
     410:	a3 5a       	subi	r26, 0xA3	; 163
     412:	bf 4f       	sbci	r27, 0xFF	; 255
     414:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     416:	84 8d       	ldd	r24, Z+28	; 0x1c
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	01 96       	adiw	r24, 0x01	; 1
     41c:	8f 73       	andi	r24, 0x3F	; 63
     41e:	99 27       	eor	r25, r25
     420:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     422:	a6 89       	ldd	r26, Z+22	; 0x16
     424:	b7 89       	ldd	r27, Z+23	; 0x17
     426:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     428:	a0 89       	ldd	r26, Z+16	; 0x10
     42a:	b1 89       	ldd	r27, Z+17	; 0x11
     42c:	8c 91       	ld	r24, X
     42e:	83 70       	andi	r24, 0x03	; 3
     430:	80 64       	ori	r24, 0x40	; 64
     432:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     434:	93 8d       	ldd	r25, Z+27	; 0x1b
     436:	84 8d       	ldd	r24, Z+28	; 0x1c
     438:	98 13       	cpse	r25, r24
     43a:	06 c0       	rjmp	.+12     	; 0x448 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     43c:	02 88       	ldd	r0, Z+18	; 0x12
     43e:	f3 89       	ldd	r31, Z+19	; 0x13
     440:	e0 2d       	mov	r30, r0
     442:	80 81       	ld	r24, Z
     444:	8f 7d       	andi	r24, 0xDF	; 223
     446:	80 83       	st	Z, r24
     448:	08 95       	ret

0000044a <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     44a:	ef 92       	push	r14
     44c:	ff 92       	push	r15
     44e:	0f 93       	push	r16
     450:	1f 93       	push	r17
     452:	cf 93       	push	r28
     454:	df 93       	push	r29
     456:	ec 01       	movw	r28, r24
  _written = true;
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     45c:	9b 8d       	ldd	r25, Y+27	; 0x1b
     45e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     460:	98 13       	cpse	r25, r24
     462:	05 c0       	rjmp	.+10     	; 0x46e <_ZN14HardwareSerial5writeEh+0x24>
     464:	e8 89       	ldd	r30, Y+16	; 0x10
     466:	f9 89       	ldd	r31, Y+17	; 0x11
     468:	80 81       	ld	r24, Z
     46a:	85 fd       	sbrc	r24, 5
     46c:	26 c0       	rjmp	.+76     	; 0x4ba <_ZN14HardwareSerial5writeEh+0x70>
     46e:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     470:	0b 8d       	ldd	r16, Y+27	; 0x1b
     472:	10 e0       	ldi	r17, 0x00	; 0
     474:	0f 5f       	subi	r16, 0xFF	; 255
     476:	1f 4f       	sbci	r17, 0xFF	; 255
     478:	0f 73       	andi	r16, 0x3F	; 63
     47a:	11 27       	eor	r17, r17
     47c:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     47e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     480:	e8 12       	cpse	r14, r24
     482:	0c c0       	rjmp	.+24     	; 0x49c <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	07 fc       	sbrc	r0, 7
     488:	fa cf       	rjmp	.-12     	; 0x47e <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     48a:	e8 89       	ldd	r30, Y+16	; 0x10
     48c:	f9 89       	ldd	r31, Y+17	; 0x11
     48e:	80 81       	ld	r24, Z
     490:	85 ff       	sbrs	r24, 5
     492:	f5 cf       	rjmp	.-22     	; 0x47e <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
     494:	ce 01       	movw	r24, r28
     496:	0e 94 03 02 	call	0x406	; 0x406 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     49a:	f1 cf       	rjmp	.-30     	; 0x47e <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     49c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     49e:	fe 01       	movw	r30, r28
     4a0:	e8 0f       	add	r30, r24
     4a2:	f1 1d       	adc	r31, r1
     4a4:	e3 5a       	subi	r30, 0xA3	; 163
     4a6:	ff 4f       	sbci	r31, 0xFF	; 255
     4a8:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     4aa:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     4ac:	f8 94       	cli
    _tx_buffer_head = i;
     4ae:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
     4b0:	ea 89       	ldd	r30, Y+18	; 0x12
     4b2:	fb 89       	ldd	r31, Y+19	; 0x13
     4b4:	80 81       	ld	r24, Z
     4b6:	80 62       	ori	r24, 0x20	; 32
     4b8:	0a c0       	rjmp	.+20     	; 0x4ce <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     4ba:	9f b7       	in	r25, 0x3f	; 63
     4bc:	f8 94       	cli
      *_udr = c;
     4be:	ee 89       	ldd	r30, Y+22	; 0x16
     4c0:	ff 89       	ldd	r31, Y+23	; 0x17
     4c2:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     4c4:	e8 89       	ldd	r30, Y+16	; 0x10
     4c6:	f9 89       	ldd	r31, Y+17	; 0x11
     4c8:	80 81       	ld	r24, Z
     4ca:	83 70       	andi	r24, 0x03	; 3
     4cc:	80 64       	ori	r24, 0x40	; 64
     4ce:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     4d0:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
     4d2:	81 e0       	ldi	r24, 0x01	; 1
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	df 91       	pop	r29
     4d8:	cf 91       	pop	r28
     4da:	1f 91       	pop	r17
     4dc:	0f 91       	pop	r16
     4de:	ff 90       	pop	r15
     4e0:	ef 90       	pop	r14
     4e2:	08 95       	ret

000004e4 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     4ea:	88 8d       	ldd	r24, Y+24	; 0x18
     4ec:	88 23       	and	r24, r24
     4ee:	c9 f0       	breq	.+50     	; 0x522 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     4f0:	ea 89       	ldd	r30, Y+18	; 0x12
     4f2:	fb 89       	ldd	r31, Y+19	; 0x13
     4f4:	80 81       	ld	r24, Z
     4f6:	85 fd       	sbrc	r24, 5
     4f8:	05 c0       	rjmp	.+10     	; 0x504 <_ZN14HardwareSerial5flushEv+0x20>
     4fa:	a8 89       	ldd	r26, Y+16	; 0x10
     4fc:	b9 89       	ldd	r27, Y+17	; 0x11
     4fe:	8c 91       	ld	r24, X
     500:	86 fd       	sbrc	r24, 6
     502:	0f c0       	rjmp	.+30     	; 0x522 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     504:	0f b6       	in	r0, 0x3f	; 63
     506:	07 fc       	sbrc	r0, 7
     508:	f5 cf       	rjmp	.-22     	; 0x4f4 <_ZN14HardwareSerial5flushEv+0x10>
     50a:	80 81       	ld	r24, Z
     50c:	85 ff       	sbrs	r24, 5
     50e:	f2 cf       	rjmp	.-28     	; 0x4f4 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     510:	a8 89       	ldd	r26, Y+16	; 0x10
     512:	b9 89       	ldd	r27, Y+17	; 0x11
     514:	8c 91       	ld	r24, X
     516:	85 ff       	sbrs	r24, 5
     518:	ed cf       	rjmp	.-38     	; 0x4f4 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
     51a:	ce 01       	movw	r24, r28
     51c:	0e 94 03 02 	call	0x406	; 0x406 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     520:	e7 cf       	rjmp	.-50     	; 0x4f0 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     522:	df 91       	pop	r29
     524:	cf 91       	pop	r28
     526:	08 95       	ret

00000528 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
     528:	cf 92       	push	r12
     52a:	df 92       	push	r13
     52c:	ef 92       	push	r14
     52e:	ff 92       	push	r15
     530:	1f 93       	push	r17
     532:	cf 93       	push	r28
     534:	df 93       	push	r29
     536:	ec 01       	movw	r28, r24
     538:	6a 01       	movw	r12, r20
     53a:	7b 01       	movw	r14, r22
     53c:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     53e:	e8 89       	ldd	r30, Y+16	; 0x10
     540:	f9 89       	ldd	r31, Y+17	; 0x11
     542:	82 e0       	ldi	r24, 0x02	; 2
     544:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     546:	41 15       	cp	r20, r1
     548:	51 4e       	sbci	r21, 0xE1	; 225
     54a:	61 05       	cpc	r22, r1
     54c:	71 05       	cpc	r23, r1
     54e:	b1 f0       	breq	.+44     	; 0x57c <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	79 e0       	ldi	r23, 0x09	; 9
     554:	8d e3       	ldi	r24, 0x3D	; 61
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	a7 01       	movw	r20, r14
     55a:	96 01       	movw	r18, r12
     55c:	0e 94 33 11 	call	0x2266	; 0x2266 <__udivmodsi4>
     560:	da 01       	movw	r26, r20
     562:	c9 01       	movw	r24, r18
     564:	01 97       	sbiw	r24, 0x01	; 1
     566:	a1 09       	sbc	r26, r1
     568:	b1 09       	sbc	r27, r1
     56a:	b6 95       	lsr	r27
     56c:	a7 95       	ror	r26
     56e:	97 95       	ror	r25
     570:	87 95       	ror	r24
     572:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     574:	21 15       	cp	r18, r1
     576:	80 e1       	ldi	r24, 0x10	; 16
     578:	38 07       	cpc	r19, r24
     57a:	a8 f0       	brcs	.+42     	; 0x5a6 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
     57c:	e8 89       	ldd	r30, Y+16	; 0x10
     57e:	f9 89       	ldd	r31, Y+17	; 0x11
     580:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     582:	60 e8       	ldi	r22, 0x80	; 128
     584:	74 e8       	ldi	r23, 0x84	; 132
     586:	8e e1       	ldi	r24, 0x1E	; 30
     588:	90 e0       	ldi	r25, 0x00	; 0
     58a:	a7 01       	movw	r20, r14
     58c:	96 01       	movw	r18, r12
     58e:	0e 94 33 11 	call	0x2266	; 0x2266 <__udivmodsi4>
     592:	da 01       	movw	r26, r20
     594:	c9 01       	movw	r24, r18
     596:	01 97       	sbiw	r24, 0x01	; 1
     598:	a1 09       	sbc	r26, r1
     59a:	b1 09       	sbc	r27, r1
     59c:	b6 95       	lsr	r27
     59e:	a7 95       	ror	r26
     5a0:	97 95       	ror	r25
     5a2:	87 95       	ror	r24
     5a4:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     5a6:	ec 85       	ldd	r30, Y+12	; 0x0c
     5a8:	fd 85       	ldd	r31, Y+13	; 0x0d
     5aa:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
     5ac:	ee 85       	ldd	r30, Y+14	; 0x0e
     5ae:	ff 85       	ldd	r31, Y+15	; 0x0f
     5b0:	20 83       	st	Z, r18

  _written = false;
     5b2:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     5b4:	ec 89       	ldd	r30, Y+20	; 0x14
     5b6:	fd 89       	ldd	r31, Y+21	; 0x15
     5b8:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
     5ba:	ea 89       	ldd	r30, Y+18	; 0x12
     5bc:	fb 89       	ldd	r31, Y+19	; 0x13
     5be:	80 81       	ld	r24, Z
     5c0:	80 61       	ori	r24, 0x10	; 16
     5c2:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
     5c4:	ea 89       	ldd	r30, Y+18	; 0x12
     5c6:	fb 89       	ldd	r31, Y+19	; 0x13
     5c8:	80 81       	ld	r24, Z
     5ca:	88 60       	ori	r24, 0x08	; 8
     5cc:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
     5ce:	ea 89       	ldd	r30, Y+18	; 0x12
     5d0:	fb 89       	ldd	r31, Y+19	; 0x13
     5d2:	80 81       	ld	r24, Z
     5d4:	80 68       	ori	r24, 0x80	; 128
     5d6:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
     5d8:	ea 89       	ldd	r30, Y+18	; 0x12
     5da:	fb 89       	ldd	r31, Y+19	; 0x13
     5dc:	80 81       	ld	r24, Z
     5de:	8f 7d       	andi	r24, 0xDF	; 223
     5e0:	80 83       	st	Z, r24
}
     5e2:	df 91       	pop	r29
     5e4:	cf 91       	pop	r28
     5e6:	1f 91       	pop	r17
     5e8:	ff 90       	pop	r15
     5ea:	ef 90       	pop	r14
     5ec:	df 90       	pop	r13
     5ee:	cf 90       	pop	r12
     5f0:	08 95       	ret

000005f2 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     5f2:	1f 92       	push	r1
     5f4:	0f 92       	push	r0
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	0f 92       	push	r0
     5fa:	11 24       	eor	r1, r1
     5fc:	2f 93       	push	r18
     5fe:	8f 93       	push	r24
     600:	9f 93       	push	r25
     602:	ef 93       	push	r30
     604:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     606:	e0 91 76 01 	lds	r30, 0x0176	; 0x800176 <Serial+0x10>
     60a:	f0 91 77 01 	lds	r31, 0x0177	; 0x800177 <Serial+0x11>
     60e:	80 81       	ld	r24, Z
     610:	e0 91 7c 01 	lds	r30, 0x017C	; 0x80017c <Serial+0x16>
     614:	f0 91 7d 01 	lds	r31, 0x017D	; 0x80017d <Serial+0x17>
     618:	82 fd       	sbrc	r24, 2
     61a:	12 c0       	rjmp	.+36     	; 0x640 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     61c:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     61e:	80 91 7f 01 	lds	r24, 0x017F	; 0x80017f <Serial+0x19>
     622:	8f 5f       	subi	r24, 0xFF	; 255
     624:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     626:	20 91 80 01 	lds	r18, 0x0180	; 0x800180 <Serial+0x1a>
     62a:	82 17       	cp	r24, r18
     62c:	51 f0       	breq	.+20     	; 0x642 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
     62e:	e0 91 7f 01 	lds	r30, 0x017F	; 0x80017f <Serial+0x19>
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	ea 59       	subi	r30, 0x9A	; 154
     636:	fe 4f       	sbci	r31, 0xFE	; 254
     638:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
     63a:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <Serial+0x19>
     63e:	01 c0       	rjmp	.+2      	; 0x642 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     640:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
     642:	ff 91       	pop	r31
     644:	ef 91       	pop	r30
     646:	9f 91       	pop	r25
     648:	8f 91       	pop	r24
     64a:	2f 91       	pop	r18
     64c:	0f 90       	pop	r0
     64e:	0f be       	out	0x3f, r0	; 63
     650:	0f 90       	pop	r0
     652:	1f 90       	pop	r1
     654:	18 95       	reti

00000656 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     656:	1f 92       	push	r1
     658:	0f 92       	push	r0
     65a:	0f b6       	in	r0, 0x3f	; 63
     65c:	0f 92       	push	r0
     65e:	11 24       	eor	r1, r1
     660:	2f 93       	push	r18
     662:	3f 93       	push	r19
     664:	4f 93       	push	r20
     666:	5f 93       	push	r21
     668:	6f 93       	push	r22
     66a:	7f 93       	push	r23
     66c:	8f 93       	push	r24
     66e:	9f 93       	push	r25
     670:	af 93       	push	r26
     672:	bf 93       	push	r27
     674:	ef 93       	push	r30
     676:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
     678:	86 e6       	ldi	r24, 0x66	; 102
     67a:	91 e0       	ldi	r25, 0x01	; 1
     67c:	0e 94 03 02 	call	0x406	; 0x406 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
     680:	ff 91       	pop	r31
     682:	ef 91       	pop	r30
     684:	bf 91       	pop	r27
     686:	af 91       	pop	r26
     688:	9f 91       	pop	r25
     68a:	8f 91       	pop	r24
     68c:	7f 91       	pop	r23
     68e:	6f 91       	pop	r22
     690:	5f 91       	pop	r21
     692:	4f 91       	pop	r20
     694:	3f 91       	pop	r19
     696:	2f 91       	pop	r18
     698:	0f 90       	pop	r0
     69a:	0f be       	out	0x3f, r0	; 63
     69c:	0f 90       	pop	r0
     69e:	1f 90       	pop	r1
     6a0:	18 95       	reti

000006a2 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     6a2:	86 e6       	ldi	r24, 0x66	; 102
     6a4:	91 e0       	ldi	r25, 0x01	; 1
     6a6:	0e 94 b8 01 	call	0x370	; 0x370 <_ZN14HardwareSerial9availableEv>
     6aa:	21 e0       	ldi	r18, 0x01	; 1
     6ac:	89 2b       	or	r24, r25
     6ae:	09 f4       	brne	.+2      	; 0x6b2 <_Z17Serial0_availablev+0x10>
     6b0:	20 e0       	ldi	r18, 0x00	; 0
}
     6b2:	82 2f       	mov	r24, r18
     6b4:	08 95       	ret

000006b6 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     6b6:	e6 e6       	ldi	r30, 0x66	; 102
     6b8:	f1 e0       	ldi	r31, 0x01	; 1
     6ba:	13 82       	std	Z+3, r1	; 0x03
     6bc:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
     6be:	88 ee       	ldi	r24, 0xE8	; 232
     6c0:	93 e0       	ldi	r25, 0x03	; 3
     6c2:	a0 e0       	ldi	r26, 0x00	; 0
     6c4:	b0 e0       	ldi	r27, 0x00	; 0
     6c6:	84 83       	std	Z+4, r24	; 0x04
     6c8:	95 83       	std	Z+5, r25	; 0x05
     6ca:	a6 83       	std	Z+6, r26	; 0x06
     6cc:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     6ce:	84 e3       	ldi	r24, 0x34	; 52
     6d0:	91 e0       	ldi	r25, 0x01	; 1
     6d2:	91 83       	std	Z+1, r25	; 0x01
     6d4:	80 83       	st	Z, r24
     6d6:	85 ec       	ldi	r24, 0xC5	; 197
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	95 87       	std	Z+13, r25	; 0x0d
     6dc:	84 87       	std	Z+12, r24	; 0x0c
     6de:	84 ec       	ldi	r24, 0xC4	; 196
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	97 87       	std	Z+15, r25	; 0x0f
     6e4:	86 87       	std	Z+14, r24	; 0x0e
     6e6:	80 ec       	ldi	r24, 0xC0	; 192
     6e8:	90 e0       	ldi	r25, 0x00	; 0
     6ea:	91 8b       	std	Z+17, r25	; 0x11
     6ec:	80 8b       	std	Z+16, r24	; 0x10
     6ee:	81 ec       	ldi	r24, 0xC1	; 193
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	93 8b       	std	Z+19, r25	; 0x13
     6f4:	82 8b       	std	Z+18, r24	; 0x12
     6f6:	82 ec       	ldi	r24, 0xC2	; 194
     6f8:	90 e0       	ldi	r25, 0x00	; 0
     6fa:	95 8b       	std	Z+21, r25	; 0x15
     6fc:	84 8b       	std	Z+20, r24	; 0x14
     6fe:	86 ec       	ldi	r24, 0xC6	; 198
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	97 8b       	std	Z+23, r25	; 0x17
     704:	86 8b       	std	Z+22, r24	; 0x16
     706:	11 8e       	std	Z+25, r1	; 0x19
     708:	12 8e       	std	Z+26, r1	; 0x1a
     70a:	13 8e       	std	Z+27, r1	; 0x1b
     70c:	14 8e       	std	Z+28, r1	; 0x1c
     70e:	08 95       	ret

00000710 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
     710:	0e 94 36 05 	call	0xa6c	; 0xa6c <init>

	initVariant();
     714:	0e 94 bd 0c 	call	0x197a	; 0x197a <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
     718:	0e 94 b4 00 	call	0x168	; 0x168 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     71c:	c5 ef       	ldi	r28, 0xF5	; 245
     71e:	d1 e0       	ldi	r29, 0x01	; 1
#endif
	
	setup();
    
	for (;;) {
		loop();
     720:	0e 94 0d 01 	call	0x21a	; 0x21a <loop>
		if (serialEventRun) serialEventRun();
     724:	20 97       	sbiw	r28, 0x00	; 0
     726:	e1 f3       	breq	.-8      	; 0x720 <main+0x10>
     728:	0e 94 f5 01 	call	0x3ea	; 0x3ea <_Z14serialEventRunv>
     72c:	f9 cf       	rjmp	.-14     	; 0x720 <main+0x10>

0000072e <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
     72e:	cf 92       	push	r12
     730:	df 92       	push	r13
     732:	ef 92       	push	r14
     734:	ff 92       	push	r15
     736:	0f 93       	push	r16
     738:	1f 93       	push	r17
     73a:	cf 93       	push	r28
     73c:	df 93       	push	r29
     73e:	6c 01       	movw	r12, r24
     740:	7a 01       	movw	r14, r20
     742:	8b 01       	movw	r16, r22
     744:	c0 e0       	ldi	r28, 0x00	; 0
     746:	d0 e0       	ldi	r29, 0x00	; 0
     748:	ce 15       	cp	r28, r14
     74a:	df 05       	cpc	r29, r15
     74c:	81 f0       	breq	.+32     	; 0x76e <_ZN5Print5writeEPKhj+0x40>
     74e:	d8 01       	movw	r26, r16
     750:	6d 91       	ld	r22, X+
     752:	8d 01       	movw	r16, r26
     754:	d6 01       	movw	r26, r12
     756:	ed 91       	ld	r30, X+
     758:	fc 91       	ld	r31, X
     75a:	01 90       	ld	r0, Z+
     75c:	f0 81       	ld	r31, Z
     75e:	e0 2d       	mov	r30, r0
     760:	c6 01       	movw	r24, r12
     762:	09 95       	icall
     764:	89 2b       	or	r24, r25
     766:	11 f0       	breq	.+4      	; 0x76c <_ZN5Print5writeEPKhj+0x3e>
     768:	21 96       	adiw	r28, 0x01	; 1
     76a:	ee cf       	rjmp	.-36     	; 0x748 <_ZN5Print5writeEPKhj+0x1a>
     76c:	7e 01       	movw	r14, r28
     76e:	c7 01       	movw	r24, r14
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	ff 90       	pop	r15
     77a:	ef 90       	pop	r14
     77c:	df 90       	pop	r13
     77e:	cf 90       	pop	r12
     780:	08 95       	ret

00000782 <_ZN5Print5writeEPKc>:
     782:	61 15       	cp	r22, r1
     784:	71 05       	cpc	r23, r1
     786:	79 f0       	breq	.+30     	; 0x7a6 <_ZN5Print5writeEPKc+0x24>
     788:	fb 01       	movw	r30, r22
     78a:	01 90       	ld	r0, Z+
     78c:	00 20       	and	r0, r0
     78e:	e9 f7       	brne	.-6      	; 0x78a <_ZN5Print5writeEPKc+0x8>
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	af 01       	movw	r20, r30
     794:	46 1b       	sub	r20, r22
     796:	57 0b       	sbc	r21, r23
     798:	dc 01       	movw	r26, r24
     79a:	ed 91       	ld	r30, X+
     79c:	fc 91       	ld	r31, X
     79e:	02 80       	ldd	r0, Z+2	; 0x02
     7a0:	f3 81       	ldd	r31, Z+3	; 0x03
     7a2:	e0 2d       	mov	r30, r0
     7a4:	09 94       	ijmp
     7a6:	80 e0       	ldi	r24, 0x00	; 0
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	08 95       	ret

000007ac <_ZN5Print5printEc>:
     7ac:	dc 01       	movw	r26, r24
     7ae:	ed 91       	ld	r30, X+
     7b0:	fc 91       	ld	r31, X
     7b2:	01 90       	ld	r0, Z+
     7b4:	f0 81       	ld	r31, Z
     7b6:	e0 2d       	mov	r30, r0
     7b8:	09 94       	ijmp

000007ba <_ZN5Print7printlnEv>:
     7ba:	62 e4       	ldi	r22, 0x42	; 66
     7bc:	71 e0       	ldi	r23, 0x01	; 1
     7be:	0c 94 c1 03 	jmp	0x782	; 0x782 <_ZN5Print5writeEPKc>

000007c2 <_ZN5Print11printNumberEmh>:
     7c2:	8f 92       	push	r8
     7c4:	9f 92       	push	r9
     7c6:	af 92       	push	r10
     7c8:	bf 92       	push	r11
     7ca:	ef 92       	push	r14
     7cc:	ff 92       	push	r15
     7ce:	0f 93       	push	r16
     7d0:	1f 93       	push	r17
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
     7d6:	cd b7       	in	r28, 0x3d	; 61
     7d8:	de b7       	in	r29, 0x3e	; 62
     7da:	a1 97       	sbiw	r28, 0x21	; 33
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	de bf       	out	0x3e, r29	; 62
     7e2:	0f be       	out	0x3f, r0	; 63
     7e4:	cd bf       	out	0x3d, r28	; 61
     7e6:	7c 01       	movw	r14, r24
     7e8:	fa 01       	movw	r30, r20
     7ea:	cb 01       	movw	r24, r22
     7ec:	19 a2       	std	Y+33, r1	; 0x21
     7ee:	22 30       	cpi	r18, 0x02	; 2
     7f0:	08 f4       	brcc	.+2      	; 0x7f4 <_ZN5Print11printNumberEmh+0x32>
     7f2:	2a e0       	ldi	r18, 0x0A	; 10
     7f4:	8e 01       	movw	r16, r28
     7f6:	0f 5d       	subi	r16, 0xDF	; 223
     7f8:	1f 4f       	sbci	r17, 0xFF	; 255
     7fa:	82 2e       	mov	r8, r18
     7fc:	91 2c       	mov	r9, r1
     7fe:	a1 2c       	mov	r10, r1
     800:	b1 2c       	mov	r11, r1
     802:	bf 01       	movw	r22, r30
     804:	a5 01       	movw	r20, r10
     806:	94 01       	movw	r18, r8
     808:	0e 94 33 11 	call	0x2266	; 0x2266 <__udivmodsi4>
     80c:	f9 01       	movw	r30, r18
     80e:	ca 01       	movw	r24, r20
     810:	01 50       	subi	r16, 0x01	; 1
     812:	11 09       	sbc	r17, r1
     814:	6a 30       	cpi	r22, 0x0A	; 10
     816:	10 f4       	brcc	.+4      	; 0x81c <_ZN5Print11printNumberEmh+0x5a>
     818:	60 5d       	subi	r22, 0xD0	; 208
     81a:	01 c0       	rjmp	.+2      	; 0x81e <_ZN5Print11printNumberEmh+0x5c>
     81c:	69 5c       	subi	r22, 0xC9	; 201
     81e:	d8 01       	movw	r26, r16
     820:	6c 93       	st	X, r22
     822:	23 2b       	or	r18, r19
     824:	24 2b       	or	r18, r20
     826:	25 2b       	or	r18, r21
     828:	61 f7       	brne	.-40     	; 0x802 <_ZN5Print11printNumberEmh+0x40>
     82a:	b8 01       	movw	r22, r16
     82c:	c7 01       	movw	r24, r14
     82e:	0e 94 c1 03 	call	0x782	; 0x782 <_ZN5Print5writeEPKc>
     832:	a1 96       	adiw	r28, 0x21	; 33
     834:	0f b6       	in	r0, 0x3f	; 63
     836:	f8 94       	cli
     838:	de bf       	out	0x3e, r29	; 62
     83a:	0f be       	out	0x3f, r0	; 63
     83c:	cd bf       	out	0x3d, r28	; 61
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	0f 91       	pop	r16
     846:	ff 90       	pop	r15
     848:	ef 90       	pop	r14
     84a:	bf 90       	pop	r11
     84c:	af 90       	pop	r10
     84e:	9f 90       	pop	r9
     850:	8f 90       	pop	r8
     852:	08 95       	ret

00000854 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
     854:	cf 92       	push	r12
     856:	df 92       	push	r13
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	0f 93       	push	r16
     85e:	1f 93       	push	r17
     860:	cf 93       	push	r28
     862:	df 93       	push	r29
  if (base == 0) {
     864:	21 15       	cp	r18, r1
     866:	31 05       	cpc	r19, r1
     868:	81 f4       	brne	.+32     	; 0x88a <_ZN5Print5printEli+0x36>
    return write(n);
     86a:	dc 01       	movw	r26, r24
     86c:	ed 91       	ld	r30, X+
     86e:	fc 91       	ld	r31, X
     870:	01 90       	ld	r0, Z+
     872:	f0 81       	ld	r31, Z
     874:	e0 2d       	mov	r30, r0
     876:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
     878:	df 91       	pop	r29
     87a:	cf 91       	pop	r28
     87c:	1f 91       	pop	r17
     87e:	0f 91       	pop	r16
     880:	ff 90       	pop	r15
     882:	ef 90       	pop	r14
     884:	df 90       	pop	r13
     886:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
     888:	09 94       	ijmp
  } else if (base == 10) {
     88a:	2a 30       	cpi	r18, 0x0A	; 10
     88c:	31 05       	cpc	r19, r1
     88e:	01 f5       	brne	.+64     	; 0x8d0 <_ZN5Print5printEli+0x7c>
    if (n < 0) {
     890:	77 ff       	sbrs	r23, 7
     892:	1d c0       	rjmp	.+58     	; 0x8ce <_ZN5Print5printEli+0x7a>
     894:	6a 01       	movw	r12, r20
     896:	7b 01       	movw	r14, r22
     898:	ec 01       	movw	r28, r24
      int t = print('-');
     89a:	6d e2       	ldi	r22, 0x2D	; 45
     89c:	0e 94 d6 03 	call	0x7ac	; 0x7ac <_ZN5Print5printEc>
     8a0:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
     8a2:	44 27       	eor	r20, r20
     8a4:	55 27       	eor	r21, r21
     8a6:	ba 01       	movw	r22, r20
     8a8:	4c 19       	sub	r20, r12
     8aa:	5d 09       	sbc	r21, r13
     8ac:	6e 09       	sbc	r22, r14
     8ae:	7f 09       	sbc	r23, r15
     8b0:	2a e0       	ldi	r18, 0x0A	; 10
     8b2:	ce 01       	movw	r24, r28
     8b4:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <_ZN5Print11printNumberEmh>
     8b8:	80 0f       	add	r24, r16
     8ba:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
     8bc:	df 91       	pop	r29
     8be:	cf 91       	pop	r28
     8c0:	1f 91       	pop	r17
     8c2:	0f 91       	pop	r16
     8c4:	ff 90       	pop	r15
     8c6:	ef 90       	pop	r14
     8c8:	df 90       	pop	r13
     8ca:	cf 90       	pop	r12
     8cc:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
     8ce:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	1f 91       	pop	r17
     8d6:	0f 91       	pop	r16
     8d8:	ff 90       	pop	r15
     8da:	ef 90       	pop	r14
     8dc:	df 90       	pop	r13
     8de:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
     8e0:	0c 94 e1 03 	jmp	0x7c2	; 0x7c2 <_ZN5Print11printNumberEmh>

000008e4 <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
     8e4:	9a 01       	movw	r18, r20
  return print((long) n, base);
     8e6:	ab 01       	movw	r20, r22
     8e8:	77 0f       	add	r23, r23
     8ea:	66 0b       	sbc	r22, r22
     8ec:	77 0b       	sbc	r23, r23
     8ee:	0c 94 2a 04 	jmp	0x854	; 0x854 <_ZN5Print5printEli>

000008f2 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
     8f2:	0f 93       	push	r16
     8f4:	1f 93       	push	r17
     8f6:	cf 93       	push	r28
     8f8:	df 93       	push	r29
     8fa:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
     8fc:	0e 94 72 04 	call	0x8e4	; 0x8e4 <_ZN5Print5printEii>
     900:	8c 01       	movw	r16, r24
  n += println();
     902:	ce 01       	movw	r24, r28
     904:	0e 94 dd 03 	call	0x7ba	; 0x7ba <_ZN5Print7printlnEv>
  return n;
}
     908:	80 0f       	add	r24, r16
     90a:	91 1f       	adc	r25, r17
     90c:	df 91       	pop	r29
     90e:	cf 91       	pop	r28
     910:	1f 91       	pop	r17
     912:	0f 91       	pop	r16
     914:	08 95       	ret

00000916 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
     916:	1f 92       	push	r1
     918:	0f 92       	push	r0
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	0f 92       	push	r0
     91e:	11 24       	eor	r1, r1
     920:	2f 93       	push	r18
     922:	3f 93       	push	r19
     924:	8f 93       	push	r24
     926:	9f 93       	push	r25
     928:	af 93       	push	r26
     92a:	bf 93       	push	r27
     92c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <timer0_millis>
     930:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <timer0_millis+0x1>
     934:	a0 91 06 02 	lds	r26, 0x0206	; 0x800206 <timer0_millis+0x2>
     938:	b0 91 07 02 	lds	r27, 0x0207	; 0x800207 <timer0_millis+0x3>
     93c:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <timer0_fract>
     940:	23 e0       	ldi	r18, 0x03	; 3
     942:	23 0f       	add	r18, r19
     944:	2d 37       	cpi	r18, 0x7D	; 125
     946:	20 f4       	brcc	.+8      	; 0x950 <__vector_16+0x3a>
     948:	01 96       	adiw	r24, 0x01	; 1
     94a:	a1 1d       	adc	r26, r1
     94c:	b1 1d       	adc	r27, r1
     94e:	05 c0       	rjmp	.+10     	; 0x95a <__vector_16+0x44>
     950:	26 e8       	ldi	r18, 0x86	; 134
     952:	23 0f       	add	r18, r19
     954:	02 96       	adiw	r24, 0x02	; 2
     956:	a1 1d       	adc	r26, r1
     958:	b1 1d       	adc	r27, r1
     95a:	20 93 03 02 	sts	0x0203, r18	; 0x800203 <timer0_fract>
     95e:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <timer0_millis>
     962:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <timer0_millis+0x1>
     966:	a0 93 06 02 	sts	0x0206, r26	; 0x800206 <timer0_millis+0x2>
     96a:	b0 93 07 02 	sts	0x0207, r27	; 0x800207 <timer0_millis+0x3>
     96e:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <timer0_overflow_count>
     972:	90 91 09 02 	lds	r25, 0x0209	; 0x800209 <timer0_overflow_count+0x1>
     976:	a0 91 0a 02 	lds	r26, 0x020A	; 0x80020a <timer0_overflow_count+0x2>
     97a:	b0 91 0b 02 	lds	r27, 0x020B	; 0x80020b <timer0_overflow_count+0x3>
     97e:	01 96       	adiw	r24, 0x01	; 1
     980:	a1 1d       	adc	r26, r1
     982:	b1 1d       	adc	r27, r1
     984:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <timer0_overflow_count>
     988:	90 93 09 02 	sts	0x0209, r25	; 0x800209 <timer0_overflow_count+0x1>
     98c:	a0 93 0a 02 	sts	0x020A, r26	; 0x80020a <timer0_overflow_count+0x2>
     990:	b0 93 0b 02 	sts	0x020B, r27	; 0x80020b <timer0_overflow_count+0x3>
     994:	bf 91       	pop	r27
     996:	af 91       	pop	r26
     998:	9f 91       	pop	r25
     99a:	8f 91       	pop	r24
     99c:	3f 91       	pop	r19
     99e:	2f 91       	pop	r18
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	0f 90       	pop	r0
     9a6:	1f 90       	pop	r1
     9a8:	18 95       	reti

000009aa <micros>:
     9aa:	3f b7       	in	r19, 0x3f	; 63
     9ac:	f8 94       	cli
     9ae:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <timer0_overflow_count>
     9b2:	90 91 09 02 	lds	r25, 0x0209	; 0x800209 <timer0_overflow_count+0x1>
     9b6:	a0 91 0a 02 	lds	r26, 0x020A	; 0x80020a <timer0_overflow_count+0x2>
     9ba:	b0 91 0b 02 	lds	r27, 0x020B	; 0x80020b <timer0_overflow_count+0x3>
     9be:	26 b5       	in	r18, 0x26	; 38
     9c0:	a8 9b       	sbis	0x15, 0	; 21
     9c2:	05 c0       	rjmp	.+10     	; 0x9ce <micros+0x24>
     9c4:	2f 3f       	cpi	r18, 0xFF	; 255
     9c6:	19 f0       	breq	.+6      	; 0x9ce <micros+0x24>
     9c8:	01 96       	adiw	r24, 0x01	; 1
     9ca:	a1 1d       	adc	r26, r1
     9cc:	b1 1d       	adc	r27, r1
     9ce:	3f bf       	out	0x3f, r19	; 63
     9d0:	ba 2f       	mov	r27, r26
     9d2:	a9 2f       	mov	r26, r25
     9d4:	98 2f       	mov	r25, r24
     9d6:	88 27       	eor	r24, r24
     9d8:	82 0f       	add	r24, r18
     9da:	91 1d       	adc	r25, r1
     9dc:	a1 1d       	adc	r26, r1
     9de:	b1 1d       	adc	r27, r1
     9e0:	bc 01       	movw	r22, r24
     9e2:	cd 01       	movw	r24, r26
     9e4:	42 e0       	ldi	r20, 0x02	; 2
     9e6:	66 0f       	add	r22, r22
     9e8:	77 1f       	adc	r23, r23
     9ea:	88 1f       	adc	r24, r24
     9ec:	99 1f       	adc	r25, r25
     9ee:	4a 95       	dec	r20
     9f0:	d1 f7       	brne	.-12     	; 0x9e6 <micros+0x3c>
     9f2:	08 95       	ret

000009f4 <delay>:
     9f4:	8f 92       	push	r8
     9f6:	9f 92       	push	r9
     9f8:	af 92       	push	r10
     9fa:	bf 92       	push	r11
     9fc:	cf 92       	push	r12
     9fe:	df 92       	push	r13
     a00:	ef 92       	push	r14
     a02:	ff 92       	push	r15
     a04:	6b 01       	movw	r12, r22
     a06:	7c 01       	movw	r14, r24
     a08:	0e 94 d5 04 	call	0x9aa	; 0x9aa <micros>
     a0c:	4b 01       	movw	r8, r22
     a0e:	5c 01       	movw	r10, r24
     a10:	c1 14       	cp	r12, r1
     a12:	d1 04       	cpc	r13, r1
     a14:	e1 04       	cpc	r14, r1
     a16:	f1 04       	cpc	r15, r1
     a18:	01 f1       	breq	.+64     	; 0xa5a <delay+0x66>
     a1a:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <yield>
     a1e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <micros>
     a22:	dc 01       	movw	r26, r24
     a24:	cb 01       	movw	r24, r22
     a26:	88 19       	sub	r24, r8
     a28:	99 09       	sbc	r25, r9
     a2a:	aa 09       	sbc	r26, r10
     a2c:	bb 09       	sbc	r27, r11
     a2e:	88 3e       	cpi	r24, 0xE8	; 232
     a30:	93 40       	sbci	r25, 0x03	; 3
     a32:	a1 05       	cpc	r26, r1
     a34:	b1 05       	cpc	r27, r1
     a36:	60 f3       	brcs	.-40     	; 0xa10 <delay+0x1c>
     a38:	21 e0       	ldi	r18, 0x01	; 1
     a3a:	c2 1a       	sub	r12, r18
     a3c:	d1 08       	sbc	r13, r1
     a3e:	e1 08       	sbc	r14, r1
     a40:	f1 08       	sbc	r15, r1
     a42:	88 ee       	ldi	r24, 0xE8	; 232
     a44:	88 0e       	add	r8, r24
     a46:	83 e0       	ldi	r24, 0x03	; 3
     a48:	98 1e       	adc	r9, r24
     a4a:	a1 1c       	adc	r10, r1
     a4c:	b1 1c       	adc	r11, r1
     a4e:	c1 14       	cp	r12, r1
     a50:	d1 04       	cpc	r13, r1
     a52:	e1 04       	cpc	r14, r1
     a54:	f1 04       	cpc	r15, r1
     a56:	19 f7       	brne	.-58     	; 0xa1e <delay+0x2a>
     a58:	db cf       	rjmp	.-74     	; 0xa10 <delay+0x1c>
     a5a:	ff 90       	pop	r15
     a5c:	ef 90       	pop	r14
     a5e:	df 90       	pop	r13
     a60:	cf 90       	pop	r12
     a62:	bf 90       	pop	r11
     a64:	af 90       	pop	r10
     a66:	9f 90       	pop	r9
     a68:	8f 90       	pop	r8
     a6a:	08 95       	ret

00000a6c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     a6c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     a6e:	84 b5       	in	r24, 0x24	; 36
     a70:	82 60       	ori	r24, 0x02	; 2
     a72:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     a74:	84 b5       	in	r24, 0x24	; 36
     a76:	81 60       	ori	r24, 0x01	; 1
     a78:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     a7a:	85 b5       	in	r24, 0x25	; 37
     a7c:	82 60       	ori	r24, 0x02	; 2
     a7e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     a80:	85 b5       	in	r24, 0x25	; 37
     a82:	81 60       	ori	r24, 0x01	; 1
     a84:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     a86:	ee e6       	ldi	r30, 0x6E	; 110
     a88:	f0 e0       	ldi	r31, 0x00	; 0
     a8a:	80 81       	ld	r24, Z
     a8c:	81 60       	ori	r24, 0x01	; 1
     a8e:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     a90:	e1 e8       	ldi	r30, 0x81	; 129
     a92:	f0 e0       	ldi	r31, 0x00	; 0
     a94:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     a96:	80 81       	ld	r24, Z
     a98:	82 60       	ori	r24, 0x02	; 2
     a9a:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     a9c:	80 81       	ld	r24, Z
     a9e:	81 60       	ori	r24, 0x01	; 1
     aa0:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     aa2:	e0 e8       	ldi	r30, 0x80	; 128
     aa4:	f0 e0       	ldi	r31, 0x00	; 0
     aa6:	80 81       	ld	r24, Z
     aa8:	81 60       	ori	r24, 0x01	; 1
     aaa:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     aac:	e1 eb       	ldi	r30, 0xB1	; 177
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	80 81       	ld	r24, Z
     ab2:	84 60       	ori	r24, 0x04	; 4
     ab4:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     ab6:	e0 eb       	ldi	r30, 0xB0	; 176
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	80 81       	ld	r24, Z
     abc:	81 60       	ori	r24, 0x01	; 1
     abe:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     ac0:	ea e7       	ldi	r30, 0x7A	; 122
     ac2:	f0 e0       	ldi	r31, 0x00	; 0
     ac4:	80 81       	ld	r24, Z
     ac6:	84 60       	ori	r24, 0x04	; 4
     ac8:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
     aca:	80 81       	ld	r24, Z
     acc:	82 60       	ori	r24, 0x02	; 2
     ace:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
     ad0:	80 81       	ld	r24, Z
     ad2:	81 60       	ori	r24, 0x01	; 1
     ad4:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     ad6:	80 81       	ld	r24, Z
     ad8:	80 68       	ori	r24, 0x80	; 128
     ada:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     adc:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
     ae0:	08 95       	ret

00000ae2 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     ae2:	83 30       	cpi	r24, 0x03	; 3
     ae4:	81 f0       	breq	.+32     	; 0xb06 <turnOffPWM+0x24>
     ae6:	28 f4       	brcc	.+10     	; 0xaf2 <turnOffPWM+0x10>
     ae8:	81 30       	cpi	r24, 0x01	; 1
     aea:	99 f0       	breq	.+38     	; 0xb12 <turnOffPWM+0x30>
     aec:	82 30       	cpi	r24, 0x02	; 2
     aee:	a1 f0       	breq	.+40     	; 0xb18 <turnOffPWM+0x36>
     af0:	08 95       	ret
     af2:	87 30       	cpi	r24, 0x07	; 7
     af4:	a9 f0       	breq	.+42     	; 0xb20 <turnOffPWM+0x3e>
     af6:	88 30       	cpi	r24, 0x08	; 8
     af8:	b9 f0       	breq	.+46     	; 0xb28 <turnOffPWM+0x46>
     afa:	84 30       	cpi	r24, 0x04	; 4
     afc:	d1 f4       	brne	.+52     	; 0xb32 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     afe:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     b02:	8f 7d       	andi	r24, 0xDF	; 223
     b04:	03 c0       	rjmp	.+6      	; 0xb0c <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     b06:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     b0a:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     b0c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     b10:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     b12:	84 b5       	in	r24, 0x24	; 36
     b14:	8f 77       	andi	r24, 0x7F	; 127
     b16:	02 c0       	rjmp	.+4      	; 0xb1c <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     b18:	84 b5       	in	r24, 0x24	; 36
     b1a:	8f 7d       	andi	r24, 0xDF	; 223
     b1c:	84 bd       	out	0x24, r24	; 36
     b1e:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     b20:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     b24:	8f 77       	andi	r24, 0x7F	; 127
     b26:	03 c0       	rjmp	.+6      	; 0xb2e <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     b28:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     b2c:	8f 7d       	andi	r24, 0xDF	; 223
     b2e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     b32:	08 95       	ret

00000b34 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	fc 01       	movw	r30, r24
     b3c:	e0 57       	subi	r30, 0x70	; 112
     b3e:	ff 4f       	sbci	r31, 0xFF	; 255
     b40:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
     b42:	fc 01       	movw	r30, r24
     b44:	ec 55       	subi	r30, 0x5C	; 92
     b46:	ff 4f       	sbci	r31, 0xFF	; 255
     b48:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     b4a:	88 23       	and	r24, r24
     b4c:	61 f1       	breq	.+88     	; 0xba6 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	88 0f       	add	r24, r24
     b52:	99 1f       	adc	r25, r25
     b54:	fc 01       	movw	r30, r24
     b56:	ee 53       	subi	r30, 0x3E	; 62
     b58:	ff 4f       	sbci	r31, 0xFF	; 255
     b5a:	c5 91       	lpm	r28, Z+
     b5c:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
     b5e:	fc 01       	movw	r30, r24
     b60:	e8 54       	subi	r30, 0x48	; 72
     b62:	ff 4f       	sbci	r31, 0xFF	; 255
     b64:	a5 91       	lpm	r26, Z+
     b66:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
     b68:	61 11       	cpse	r22, r1
     b6a:	09 c0       	rjmp	.+18     	; 0xb7e <pinMode+0x4a>
		uint8_t oldSREG = SREG;
     b6c:	9f b7       	in	r25, 0x3f	; 63
                cli();
     b6e:	f8 94       	cli
		*reg &= ~bit;
     b70:	88 81       	ld	r24, Y
     b72:	20 95       	com	r18
     b74:	82 23       	and	r24, r18
     b76:	88 83       	st	Y, r24
		*out &= ~bit;
     b78:	ec 91       	ld	r30, X
     b7a:	2e 23       	and	r18, r30
     b7c:	0b c0       	rjmp	.+22     	; 0xb94 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
     b7e:	62 30       	cpi	r22, 0x02	; 2
     b80:	61 f4       	brne	.+24     	; 0xb9a <pinMode+0x66>
		uint8_t oldSREG = SREG;
     b82:	9f b7       	in	r25, 0x3f	; 63
                cli();
     b84:	f8 94       	cli
		*reg &= ~bit;
     b86:	88 81       	ld	r24, Y
     b88:	32 2f       	mov	r19, r18
     b8a:	30 95       	com	r19
     b8c:	83 23       	and	r24, r19
     b8e:	88 83       	st	Y, r24
		*out |= bit;
     b90:	ec 91       	ld	r30, X
     b92:	2e 2b       	or	r18, r30
     b94:	2c 93       	st	X, r18
		SREG = oldSREG;
     b96:	9f bf       	out	0x3f, r25	; 63
     b98:	06 c0       	rjmp	.+12     	; 0xba6 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
     b9a:	8f b7       	in	r24, 0x3f	; 63
                cli();
     b9c:	f8 94       	cli
		*reg |= bit;
     b9e:	e8 81       	ld	r30, Y
     ba0:	2e 2b       	or	r18, r30
     ba2:	28 83       	st	Y, r18
		SREG = oldSREG;
     ba4:	8f bf       	out	0x3f, r24	; 63
	}
}
     ba6:	df 91       	pop	r29
     ba8:	cf 91       	pop	r28
     baa:	08 95       	ret

00000bac <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     bac:	1f 93       	push	r17
     bae:	cf 93       	push	r28
     bb0:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
     bb2:	28 2f       	mov	r18, r24
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	f9 01       	movw	r30, r18
     bb8:	e4 58       	subi	r30, 0x84	; 132
     bba:	ff 4f       	sbci	r31, 0xFF	; 255
     bbc:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
     bbe:	f9 01       	movw	r30, r18
     bc0:	e0 57       	subi	r30, 0x70	; 112
     bc2:	ff 4f       	sbci	r31, 0xFF	; 255
     bc4:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
     bc6:	f9 01       	movw	r30, r18
     bc8:	ec 55       	subi	r30, 0x5C	; 92
     bca:	ff 4f       	sbci	r31, 0xFF	; 255
     bcc:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     bce:	cc 23       	and	r28, r28
     bd0:	c1 f0       	breq	.+48     	; 0xc02 <digitalWrite+0x56>
     bd2:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     bd4:	81 11       	cpse	r24, r1
     bd6:	0e 94 71 05 	call	0xae2	; 0xae2 <turnOffPWM>

	out = portOutputRegister(port);
     bda:	ec 2f       	mov	r30, r28
     bdc:	f0 e0       	ldi	r31, 0x00	; 0
     bde:	ee 0f       	add	r30, r30
     be0:	ff 1f       	adc	r31, r31
     be2:	e8 54       	subi	r30, 0x48	; 72
     be4:	ff 4f       	sbci	r31, 0xFF	; 255
     be6:	a5 91       	lpm	r26, Z+
     be8:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
     bea:	9f b7       	in	r25, 0x3f	; 63
	cli();
     bec:	f8 94       	cli

	if (val == LOW) {
     bee:	11 11       	cpse	r17, r1
     bf0:	04 c0       	rjmp	.+8      	; 0xbfa <digitalWrite+0x4e>
		*out &= ~bit;
     bf2:	8c 91       	ld	r24, X
     bf4:	d0 95       	com	r29
     bf6:	d8 23       	and	r29, r24
     bf8:	02 c0       	rjmp	.+4      	; 0xbfe <digitalWrite+0x52>
	} else {
		*out |= bit;
     bfa:	ec 91       	ld	r30, X
     bfc:	de 2b       	or	r29, r30
     bfe:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
     c00:	9f bf       	out	0x3f, r25	; 63
}
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	08 95       	ret

00000c0a <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     c0a:	e0 91 39 02 	lds	r30, 0x0239	; 0x800239 <pxDelayedTaskList>
     c0e:	f0 91 3a 02 	lds	r31, 0x023A	; 0x80023a <pxDelayedTaskList+0x1>
     c12:	80 81       	ld	r24, Z
     c14:	81 11       	cpse	r24, r1
     c16:	03 c0       	rjmp	.+6      	; 0xc1e <prvResetNextTaskUnblockTime+0x14>
     c18:	8f ef       	ldi	r24, 0xFF	; 255
     c1a:	9f ef       	ldi	r25, 0xFF	; 255
     c1c:	0c c0       	rjmp	.+24     	; 0xc36 <prvResetNextTaskUnblockTime+0x2c>
     c1e:	e0 91 39 02 	lds	r30, 0x0239	; 0x800239 <pxDelayedTaskList>
     c22:	f0 91 3a 02 	lds	r31, 0x023A	; 0x80023a <pxDelayedTaskList+0x1>
     c26:	05 80       	ldd	r0, Z+5	; 0x05
     c28:	f6 81       	ldd	r31, Z+6	; 0x06
     c2a:	e0 2d       	mov	r30, r0
     c2c:	06 80       	ldd	r0, Z+6	; 0x06
     c2e:	f7 81       	ldd	r31, Z+7	; 0x07
     c30:	e0 2d       	mov	r30, r0
     c32:	82 81       	ldd	r24, Z+2	; 0x02
     c34:	93 81       	ldd	r25, Z+3	; 0x03
     c36:	90 93 10 02 	sts	0x0210, r25	; 0x800210 <xNextTaskUnblockTime+0x1>
     c3a:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <xNextTaskUnblockTime>
     c3e:	08 95       	ret

00000c40 <prvAddCurrentTaskToDelayedList>:
     c40:	ff 92       	push	r15
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	ec 01       	movw	r28, r24
     c4c:	f6 2e       	mov	r15, r22
     c4e:	00 91 18 02 	lds	r16, 0x0218	; 0x800218 <xTickCount>
     c52:	10 91 19 02 	lds	r17, 0x0219	; 0x800219 <xTickCount+0x1>
     c56:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <pxCurrentTCB>
     c5a:	90 91 72 02 	lds	r25, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     c5e:	02 96       	adiw	r24, 0x02	; 2
     c60:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
     c64:	cf 3f       	cpi	r28, 0xFF	; 255
     c66:	8f ef       	ldi	r24, 0xFF	; 255
     c68:	d8 07       	cpc	r29, r24
     c6a:	89 f4       	brne	.+34     	; 0xc8e <prvAddCurrentTaskToDelayedList+0x4e>
     c6c:	ff 20       	and	r15, r15
     c6e:	79 f0       	breq	.+30     	; 0xc8e <prvAddCurrentTaskToDelayedList+0x4e>
     c70:	60 91 71 02 	lds	r22, 0x0271	; 0x800271 <pxCurrentTCB>
     c74:	70 91 72 02 	lds	r23, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     c78:	6e 5f       	subi	r22, 0xFE	; 254
     c7a:	7f 4f       	sbci	r23, 0xFF	; 255
     c7c:	8b e1       	ldi	r24, 0x1B	; 27
     c7e:	92 e0       	ldi	r25, 0x02	; 2
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28
     c84:	1f 91       	pop	r17
     c86:	0f 91       	pop	r16
     c88:	ff 90       	pop	r15
     c8a:	0c 94 28 0d 	jmp	0x1a50	; 0x1a50 <vListInsertEnd>
     c8e:	c0 0f       	add	r28, r16
     c90:	d1 1f       	adc	r29, r17
     c92:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
     c96:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     c9a:	d3 83       	std	Z+3, r29	; 0x03
     c9c:	c2 83       	std	Z+2, r28	; 0x02
     c9e:	60 91 71 02 	lds	r22, 0x0271	; 0x800271 <pxCurrentTCB>
     ca2:	70 91 72 02 	lds	r23, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     ca6:	c0 17       	cp	r28, r16
     ca8:	d1 07       	cpc	r29, r17
     caa:	68 f4       	brcc	.+26     	; 0xcc6 <prvAddCurrentTaskToDelayedList+0x86>
     cac:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <pxOverflowDelayedTaskList>
     cb0:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <pxOverflowDelayedTaskList+0x1>
     cb4:	6e 5f       	subi	r22, 0xFE	; 254
     cb6:	7f 4f       	sbci	r23, 0xFF	; 255
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	1f 91       	pop	r17
     cbe:	0f 91       	pop	r16
     cc0:	ff 90       	pop	r15
     cc2:	0c 94 49 0d 	jmp	0x1a92	; 0x1a92 <vListInsert>
     cc6:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <pxDelayedTaskList>
     cca:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <pxDelayedTaskList+0x1>
     cce:	6e 5f       	subi	r22, 0xFE	; 254
     cd0:	7f 4f       	sbci	r23, 0xFF	; 255
     cd2:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vListInsert>
     cd6:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <xNextTaskUnblockTime>
     cda:	90 91 10 02 	lds	r25, 0x0210	; 0x800210 <xNextTaskUnblockTime+0x1>
     cde:	c8 17       	cp	r28, r24
     ce0:	d9 07       	cpc	r29, r25
     ce2:	20 f4       	brcc	.+8      	; 0xcec <prvAddCurrentTaskToDelayedList+0xac>
     ce4:	d0 93 10 02 	sts	0x0210, r29	; 0x800210 <xNextTaskUnblockTime+0x1>
     ce8:	c0 93 0f 02 	sts	0x020F, r28	; 0x80020f <xNextTaskUnblockTime>
     cec:	df 91       	pop	r29
     cee:	cf 91       	pop	r28
     cf0:	1f 91       	pop	r17
     cf2:	0f 91       	pop	r16
     cf4:	ff 90       	pop	r15
     cf6:	08 95       	ret

00000cf8 <prvIdleTask>:
     cf8:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <uxDeletedTasksWaitingCleanUp>
     cfc:	88 23       	and	r24, r24
     cfe:	09 f1       	breq	.+66     	; 0xd42 <prvIdleTask+0x4a>
     d00:	0f b6       	in	r0, 0x3f	; 63
     d02:	f8 94       	cli
     d04:	0f 92       	push	r0
     d06:	e0 91 2a 02 	lds	r30, 0x022A	; 0x80022a <xTasksWaitingTermination+0x5>
     d0a:	f0 91 2b 02 	lds	r31, 0x022B	; 0x80022b <xTasksWaitingTermination+0x6>
     d0e:	c6 81       	ldd	r28, Z+6	; 0x06
     d10:	d7 81       	ldd	r29, Z+7	; 0x07
     d12:	ce 01       	movw	r24, r28
     d14:	02 96       	adiw	r24, 0x02	; 2
     d16:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
     d1a:	80 91 1a 02 	lds	r24, 0x021A	; 0x80021a <uxCurrentNumberOfTasks>
     d1e:	81 50       	subi	r24, 0x01	; 1
     d20:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <uxCurrentNumberOfTasks>
     d24:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <uxDeletedTasksWaitingCleanUp>
     d28:	81 50       	subi	r24, 0x01	; 1
     d2a:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <uxDeletedTasksWaitingCleanUp>
     d2e:	0f 90       	pop	r0
     d30:	0f be       	out	0x3f, r0	; 63
     d32:	8f 89       	ldd	r24, Y+23	; 0x17
     d34:	98 8d       	ldd	r25, Y+24	; 0x18
     d36:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <vPortFree>
     d3a:	ce 01       	movw	r24, r28
     d3c:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <vPortFree>
     d40:	db cf       	rjmp	.-74     	; 0xcf8 <prvIdleTask>
     d42:	80 91 4d 02 	lds	r24, 0x024D	; 0x80024d <pxReadyTasksLists>
     d46:	82 30       	cpi	r24, 0x02	; 2
     d48:	10 f0       	brcs	.+4      	; 0xd4e <prvIdleTask+0x56>
     d4a:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
     d4e:	0e 94 ce 0c 	call	0x199c	; 0x199c <vApplicationIdleHook>
     d52:	d2 cf       	rjmp	.-92     	; 0xcf8 <prvIdleTask>

00000d54 <xTaskCreate>:
     d54:	5f 92       	push	r5
     d56:	6f 92       	push	r6
     d58:	7f 92       	push	r7
     d5a:	8f 92       	push	r8
     d5c:	9f 92       	push	r9
     d5e:	af 92       	push	r10
     d60:	bf 92       	push	r11
     d62:	cf 92       	push	r12
     d64:	df 92       	push	r13
     d66:	ef 92       	push	r14
     d68:	ff 92       	push	r15
     d6a:	0f 93       	push	r16
     d6c:	1f 93       	push	r17
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	3c 01       	movw	r6, r24
     d74:	6b 01       	movw	r12, r22
     d76:	5a 01       	movw	r10, r20
     d78:	49 01       	movw	r8, r18
     d7a:	50 2e       	mov	r5, r16
     d7c:	ca 01       	movw	r24, r20
     d7e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <pvPortMalloc>
     d82:	8c 01       	movw	r16, r24
     d84:	89 2b       	or	r24, r25
     d86:	09 f4       	brne	.+2      	; 0xd8a <xTaskCreate+0x36>
     d88:	e0 c0       	rjmp	.+448    	; 0xf4a <xTaskCreate+0x1f6>
     d8a:	88 e2       	ldi	r24, 0x28	; 40
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <pvPortMalloc>
     d92:	ec 01       	movw	r28, r24
     d94:	89 2b       	or	r24, r25
     d96:	c9 f0       	breq	.+50     	; 0xdca <xTaskCreate+0x76>
     d98:	18 8f       	std	Y+24, r17	; 0x18
     d9a:	0f 8b       	std	Y+23, r16	; 0x17
     d9c:	a5 01       	movw	r20, r10
     d9e:	65 ea       	ldi	r22, 0xA5	; 165
     da0:	70 e0       	ldi	r23, 0x00	; 0
     da2:	c8 01       	movw	r24, r16
     da4:	0e 94 85 12 	call	0x250a	; 0x250a <memset>
     da8:	21 e0       	ldi	r18, 0x01	; 1
     daa:	a2 1a       	sub	r10, r18
     dac:	b1 08       	sbc	r11, r1
     dae:	8f 89       	ldd	r24, Y+23	; 0x17
     db0:	98 8d       	ldd	r25, Y+24	; 0x18
     db2:	a8 0e       	add	r10, r24
     db4:	b9 1e       	adc	r11, r25
     db6:	c1 14       	cp	r12, r1
     db8:	d1 04       	cpc	r13, r1
     dba:	c9 f0       	breq	.+50     	; 0xdee <xTaskCreate+0x9a>
     dbc:	be 01       	movw	r22, r28
     dbe:	67 5e       	subi	r22, 0xE7	; 231
     dc0:	7f 4f       	sbci	r23, 0xFF	; 255
     dc2:	f6 01       	movw	r30, r12
     dc4:	c6 01       	movw	r24, r12
     dc6:	08 96       	adiw	r24, 0x08	; 8
     dc8:	07 c0       	rjmp	.+14     	; 0xdd8 <xTaskCreate+0x84>
     dca:	c8 01       	movw	r24, r16
     dcc:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <vPortFree>
     dd0:	bc c0       	rjmp	.+376    	; 0xf4a <xTaskCreate+0x1f6>
     dd2:	e8 17       	cp	r30, r24
     dd4:	f9 07       	cpc	r31, r25
     dd6:	49 f0       	breq	.+18     	; 0xdea <xTaskCreate+0x96>
     dd8:	9f 01       	movw	r18, r30
     dda:	41 91       	ld	r20, Z+
     ddc:	db 01       	movw	r26, r22
     dde:	4d 93       	st	X+, r20
     de0:	bd 01       	movw	r22, r26
     de2:	d9 01       	movw	r26, r18
     de4:	2c 91       	ld	r18, X
     de6:	21 11       	cpse	r18, r1
     de8:	f4 cf       	rjmp	.-24     	; 0xdd2 <xTaskCreate+0x7e>
     dea:	18 a2       	std	Y+32, r1	; 0x20
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <xTaskCreate+0x9c>
     dee:	19 8e       	std	Y+25, r1	; 0x19
     df0:	05 2d       	mov	r16, r5
     df2:	04 30       	cpi	r16, 0x04	; 4
     df4:	08 f0       	brcs	.+2      	; 0xdf8 <xTaskCreate+0xa4>
     df6:	03 e0       	ldi	r16, 0x03	; 3
     df8:	0e 8b       	std	Y+22, r16	; 0x16
     dfa:	09 a3       	std	Y+33, r16	; 0x21
     dfc:	1a a2       	std	Y+34, r1	; 0x22
     dfe:	6e 01       	movw	r12, r28
     e00:	b2 e0       	ldi	r27, 0x02	; 2
     e02:	cb 0e       	add	r12, r27
     e04:	d1 1c       	adc	r13, r1
     e06:	c6 01       	movw	r24, r12
     e08:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <vListInitialiseItem>
     e0c:	ce 01       	movw	r24, r28
     e0e:	0c 96       	adiw	r24, 0x0c	; 12
     e10:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <vListInitialiseItem>
     e14:	d9 87       	std	Y+9, r29	; 0x09
     e16:	c8 87       	std	Y+8, r28	; 0x08
     e18:	84 e0       	ldi	r24, 0x04	; 4
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	80 1b       	sub	r24, r16
     e1e:	91 09       	sbc	r25, r1
     e20:	9d 87       	std	Y+13, r25	; 0x0d
     e22:	8c 87       	std	Y+12, r24	; 0x0c
     e24:	db 8b       	std	Y+19, r29	; 0x13
     e26:	ca 8b       	std	Y+18, r28	; 0x12
     e28:	1b a2       	std	Y+35, r1	; 0x23
     e2a:	1c a2       	std	Y+36, r1	; 0x24
     e2c:	1d a2       	std	Y+37, r1	; 0x25
     e2e:	1e a2       	std	Y+38, r1	; 0x26
     e30:	1f a2       	std	Y+39, r1	; 0x27
     e32:	a4 01       	movw	r20, r8
     e34:	b3 01       	movw	r22, r6
     e36:	c5 01       	movw	r24, r10
     e38:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <pxPortInitialiseStack>
     e3c:	99 83       	std	Y+1, r25	; 0x01
     e3e:	88 83       	st	Y, r24
     e40:	e1 14       	cp	r14, r1
     e42:	f1 04       	cpc	r15, r1
     e44:	19 f0       	breq	.+6      	; 0xe4c <xTaskCreate+0xf8>
     e46:	f7 01       	movw	r30, r14
     e48:	d1 83       	std	Z+1, r29	; 0x01
     e4a:	c0 83       	st	Z, r28
     e4c:	0f b6       	in	r0, 0x3f	; 63
     e4e:	f8 94       	cli
     e50:	0f 92       	push	r0
     e52:	80 91 1a 02 	lds	r24, 0x021A	; 0x80021a <uxCurrentNumberOfTasks>
     e56:	8f 5f       	subi	r24, 0xFF	; 255
     e58:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <uxCurrentNumberOfTasks>
     e5c:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <pxCurrentTCB>
     e60:	90 91 72 02 	lds	r25, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     e64:	89 2b       	or	r24, r25
     e66:	d1 f5       	brne	.+116    	; 0xedc <xTaskCreate+0x188>
     e68:	d0 93 72 02 	sts	0x0272, r29	; 0x800272 <pxCurrentTCB+0x1>
     e6c:	c0 93 71 02 	sts	0x0271, r28	; 0x800271 <pxCurrentTCB>
     e70:	80 91 1a 02 	lds	r24, 0x021A	; 0x80021a <uxCurrentNumberOfTasks>
     e74:	81 30       	cpi	r24, 0x01	; 1
     e76:	09 f0       	breq	.+2      	; 0xe7a <xTaskCreate+0x126>
     e78:	41 c0       	rjmp	.+130    	; 0xefc <xTaskCreate+0x1a8>
     e7a:	8d e4       	ldi	r24, 0x4D	; 77
     e7c:	92 e0       	ldi	r25, 0x02	; 2
     e7e:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     e82:	86 e5       	ldi	r24, 0x56	; 86
     e84:	92 e0       	ldi	r25, 0x02	; 2
     e86:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     e8a:	8f e5       	ldi	r24, 0x5F	; 95
     e8c:	92 e0       	ldi	r25, 0x02	; 2
     e8e:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     e92:	88 e6       	ldi	r24, 0x68	; 104
     e94:	92 e0       	ldi	r25, 0x02	; 2
     e96:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     e9a:	84 e4       	ldi	r24, 0x44	; 68
     e9c:	92 e0       	ldi	r25, 0x02	; 2
     e9e:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     ea2:	8b e3       	ldi	r24, 0x3B	; 59
     ea4:	92 e0       	ldi	r25, 0x02	; 2
     ea6:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     eaa:	8e e2       	ldi	r24, 0x2E	; 46
     eac:	92 e0       	ldi	r25, 0x02	; 2
     eae:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     eb2:	85 e2       	ldi	r24, 0x25	; 37
     eb4:	92 e0       	ldi	r25, 0x02	; 2
     eb6:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     eba:	8b e1       	ldi	r24, 0x1B	; 27
     ebc:	92 e0       	ldi	r25, 0x02	; 2
     ebe:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
     ec2:	84 e4       	ldi	r24, 0x44	; 68
     ec4:	92 e0       	ldi	r25, 0x02	; 2
     ec6:	90 93 3a 02 	sts	0x023A, r25	; 0x80023a <pxDelayedTaskList+0x1>
     eca:	80 93 39 02 	sts	0x0239, r24	; 0x800239 <pxDelayedTaskList>
     ece:	8b e3       	ldi	r24, 0x3B	; 59
     ed0:	92 e0       	ldi	r25, 0x02	; 2
     ed2:	90 93 38 02 	sts	0x0238, r25	; 0x800238 <pxOverflowDelayedTaskList+0x1>
     ed6:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <pxOverflowDelayedTaskList>
     eda:	10 c0       	rjmp	.+32     	; 0xefc <xTaskCreate+0x1a8>
     edc:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <xSchedulerRunning>
     ee0:	81 11       	cpse	r24, r1
     ee2:	0c c0       	rjmp	.+24     	; 0xefc <xTaskCreate+0x1a8>
     ee4:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
     ee8:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     eec:	96 89       	ldd	r25, Z+22	; 0x16
     eee:	8e 89       	ldd	r24, Y+22	; 0x16
     ef0:	89 17       	cp	r24, r25
     ef2:	20 f0       	brcs	.+8      	; 0xefc <xTaskCreate+0x1a8>
     ef4:	d0 93 72 02 	sts	0x0272, r29	; 0x800272 <pxCurrentTCB+0x1>
     ef8:	c0 93 71 02 	sts	0x0271, r28	; 0x800271 <pxCurrentTCB>
     efc:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <uxTaskNumber>
     f00:	8f 5f       	subi	r24, 0xFF	; 255
     f02:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <uxTaskNumber>
     f06:	8e 89       	ldd	r24, Y+22	; 0x16
     f08:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <uxTopReadyPriority>
     f0c:	98 17       	cp	r25, r24
     f0e:	10 f4       	brcc	.+4      	; 0xf14 <xTaskCreate+0x1c0>
     f10:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <uxTopReadyPriority>
     f14:	f9 e0       	ldi	r31, 0x09	; 9
     f16:	8f 9f       	mul	r24, r31
     f18:	c0 01       	movw	r24, r0
     f1a:	11 24       	eor	r1, r1
     f1c:	b6 01       	movw	r22, r12
     f1e:	83 5b       	subi	r24, 0xB3	; 179
     f20:	9d 4f       	sbci	r25, 0xFD	; 253
     f22:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vListInsertEnd>
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <xSchedulerRunning>
     f2e:	88 23       	and	r24, r24
     f30:	51 f0       	breq	.+20     	; 0xf46 <xTaskCreate+0x1f2>
     f32:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
     f36:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
     f3a:	96 89       	ldd	r25, Z+22	; 0x16
     f3c:	8e 89       	ldd	r24, Y+22	; 0x16
     f3e:	98 17       	cp	r25, r24
     f40:	10 f4       	brcc	.+4      	; 0xf46 <xTaskCreate+0x1f2>
     f42:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	01 c0       	rjmp	.+2      	; 0xf4c <xTaskCreate+0x1f8>
     f4a:	8f ef       	ldi	r24, 0xFF	; 255
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	1f 91       	pop	r17
     f52:	0f 91       	pop	r16
     f54:	ff 90       	pop	r15
     f56:	ef 90       	pop	r14
     f58:	df 90       	pop	r13
     f5a:	cf 90       	pop	r12
     f5c:	bf 90       	pop	r11
     f5e:	af 90       	pop	r10
     f60:	9f 90       	pop	r9
     f62:	8f 90       	pop	r8
     f64:	7f 90       	pop	r7
     f66:	6f 90       	pop	r6
     f68:	5f 90       	pop	r5
     f6a:	08 95       	ret

00000f6c <vTaskStartScheduler>:
     f6c:	ef 92       	push	r14
     f6e:	ff 92       	push	r15
     f70:	0f 93       	push	r16
     f72:	8d e0       	ldi	r24, 0x0D	; 13
     f74:	e8 2e       	mov	r14, r24
     f76:	82 e0       	ldi	r24, 0x02	; 2
     f78:	f8 2e       	mov	r15, r24
     f7a:	00 e0       	ldi	r16, 0x00	; 0
     f7c:	20 e0       	ldi	r18, 0x00	; 0
     f7e:	30 e0       	ldi	r19, 0x00	; 0
     f80:	40 ec       	ldi	r20, 0xC0	; 192
     f82:	50 e0       	ldi	r21, 0x00	; 0
     f84:	61 e5       	ldi	r22, 0x51	; 81
     f86:	71 e0       	ldi	r23, 0x01	; 1
     f88:	8c e7       	ldi	r24, 0x7C	; 124
     f8a:	96 e0       	ldi	r25, 0x06	; 6
     f8c:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskCreate>
     f90:	81 30       	cpi	r24, 0x01	; 1
     f92:	b1 f4       	brne	.+44     	; 0xfc0 <vTaskStartScheduler+0x54>
     f94:	0e 94 0a 0b 	call	0x1614	; 0x1614 <xTimerCreateTimerTask>
     f98:	81 30       	cpi	r24, 0x01	; 1
     f9a:	91 f4       	brne	.+36     	; 0xfc0 <vTaskStartScheduler+0x54>
     f9c:	f8 94       	cli
     f9e:	2f ef       	ldi	r18, 0xFF	; 255
     fa0:	3f ef       	ldi	r19, 0xFF	; 255
     fa2:	30 93 10 02 	sts	0x0210, r19	; 0x800210 <xNextTaskUnblockTime+0x1>
     fa6:	20 93 0f 02 	sts	0x020F, r18	; 0x80020f <xNextTaskUnblockTime>
     faa:	80 93 16 02 	sts	0x0216, r24	; 0x800216 <xSchedulerRunning>
     fae:	10 92 19 02 	sts	0x0219, r1	; 0x800219 <xTickCount+0x1>
     fb2:	10 92 18 02 	sts	0x0218, r1	; 0x800218 <xTickCount>
     fb6:	0f 91       	pop	r16
     fb8:	ff 90       	pop	r15
     fba:	ef 90       	pop	r14
     fbc:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <xPortStartScheduler>
     fc0:	0f 91       	pop	r16
     fc2:	ff 90       	pop	r15
     fc4:	ef 90       	pop	r14
     fc6:	08 95       	ret

00000fc8 <vTaskSuspendAll>:
     fc8:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
     fcc:	8f 5f       	subi	r24, 0xFF	; 255
     fce:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <uxSchedulerSuspended>
     fd2:	08 95       	ret

00000fd4 <xTaskGetTickCount>:
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	0f 92       	push	r0
     fda:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <xTickCount>
     fde:	90 91 19 02 	lds	r25, 0x0219	; 0x800219 <xTickCount+0x1>
     fe2:	0f 90       	pop	r0
     fe4:	0f be       	out	0x3f, r0	; 63
     fe6:	08 95       	ret

00000fe8 <xTaskIncrementTick>:
     fe8:	cf 92       	push	r12
     fea:	df 92       	push	r13
     fec:	ef 92       	push	r14
     fee:	ff 92       	push	r15
     ff0:	0f 93       	push	r16
     ff2:	1f 93       	push	r17
     ff4:	cf 93       	push	r28
     ff6:	df 93       	push	r29
     ff8:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
     ffc:	81 11       	cpse	r24, r1
     ffe:	91 c0       	rjmp	.+290    	; 0x1122 <xTaskIncrementTick+0x13a>
    1000:	00 91 18 02 	lds	r16, 0x0218	; 0x800218 <xTickCount>
    1004:	10 91 19 02 	lds	r17, 0x0219	; 0x800219 <xTickCount+0x1>
    1008:	0f 5f       	subi	r16, 0xFF	; 255
    100a:	1f 4f       	sbci	r17, 0xFF	; 255
    100c:	10 93 19 02 	sts	0x0219, r17	; 0x800219 <xTickCount+0x1>
    1010:	00 93 18 02 	sts	0x0218, r16	; 0x800218 <xTickCount>
    1014:	01 15       	cp	r16, r1
    1016:	11 05       	cpc	r17, r1
    1018:	b9 f4       	brne	.+46     	; 0x1048 <xTaskIncrementTick+0x60>
    101a:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <pxDelayedTaskList>
    101e:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <pxDelayedTaskList+0x1>
    1022:	20 91 37 02 	lds	r18, 0x0237	; 0x800237 <pxOverflowDelayedTaskList>
    1026:	30 91 38 02 	lds	r19, 0x0238	; 0x800238 <pxOverflowDelayedTaskList+0x1>
    102a:	30 93 3a 02 	sts	0x023A, r19	; 0x80023a <pxDelayedTaskList+0x1>
    102e:	20 93 39 02 	sts	0x0239, r18	; 0x800239 <pxDelayedTaskList>
    1032:	90 93 38 02 	sts	0x0238, r25	; 0x800238 <pxOverflowDelayedTaskList+0x1>
    1036:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <pxOverflowDelayedTaskList>
    103a:	80 91 12 02 	lds	r24, 0x0212	; 0x800212 <xNumOfOverflows>
    103e:	8f 5f       	subi	r24, 0xFF	; 255
    1040:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <xNumOfOverflows>
    1044:	0e 94 05 06 	call	0xc0a	; 0xc0a <prvResetNextTaskUnblockTime>
    1048:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <xNextTaskUnblockTime>
    104c:	90 91 10 02 	lds	r25, 0x0210	; 0x800210 <xNextTaskUnblockTime+0x1>
    1050:	c0 e0       	ldi	r28, 0x00	; 0
    1052:	08 17       	cp	r16, r24
    1054:	19 07       	cpc	r17, r25
    1056:	08 f4       	brcc	.+2      	; 0x105a <xTaskIncrementTick+0x72>
    1058:	4f c0       	rjmp	.+158    	; 0x10f8 <xTaskIncrementTick+0x110>
    105a:	d9 e0       	ldi	r29, 0x09	; 9
    105c:	e0 91 39 02 	lds	r30, 0x0239	; 0x800239 <pxDelayedTaskList>
    1060:	f0 91 3a 02 	lds	r31, 0x023A	; 0x80023a <pxDelayedTaskList+0x1>
    1064:	80 81       	ld	r24, Z
    1066:	81 11       	cpse	r24, r1
    1068:	03 c0       	rjmp	.+6      	; 0x1070 <xTaskIncrementTick+0x88>
    106a:	8f ef       	ldi	r24, 0xFF	; 255
    106c:	9f ef       	ldi	r25, 0xFF	; 255
    106e:	11 c0       	rjmp	.+34     	; 0x1092 <xTaskIncrementTick+0xaa>
    1070:	e0 91 39 02 	lds	r30, 0x0239	; 0x800239 <pxDelayedTaskList>
    1074:	f0 91 3a 02 	lds	r31, 0x023A	; 0x80023a <pxDelayedTaskList+0x1>
    1078:	05 80       	ldd	r0, Z+5	; 0x05
    107a:	f6 81       	ldd	r31, Z+6	; 0x06
    107c:	e0 2d       	mov	r30, r0
    107e:	e6 80       	ldd	r14, Z+6	; 0x06
    1080:	f7 80       	ldd	r15, Z+7	; 0x07
    1082:	d7 01       	movw	r26, r14
    1084:	12 96       	adiw	r26, 0x02	; 2
    1086:	8d 91       	ld	r24, X+
    1088:	9c 91       	ld	r25, X
    108a:	13 97       	sbiw	r26, 0x03	; 3
    108c:	08 17       	cp	r16, r24
    108e:	19 07       	cpc	r17, r25
    1090:	28 f4       	brcc	.+10     	; 0x109c <xTaskIncrementTick+0xb4>
    1092:	90 93 10 02 	sts	0x0210, r25	; 0x800210 <xNextTaskUnblockTime+0x1>
    1096:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <xNextTaskUnblockTime>
    109a:	2e c0       	rjmp	.+92     	; 0x10f8 <xTaskIncrementTick+0x110>
    109c:	67 01       	movw	r12, r14
    109e:	b2 e0       	ldi	r27, 0x02	; 2
    10a0:	cb 0e       	add	r12, r27
    10a2:	d1 1c       	adc	r13, r1
    10a4:	c6 01       	movw	r24, r12
    10a6:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    10aa:	f7 01       	movw	r30, r14
    10ac:	84 89       	ldd	r24, Z+20	; 0x14
    10ae:	95 89       	ldd	r25, Z+21	; 0x15
    10b0:	89 2b       	or	r24, r25
    10b2:	21 f0       	breq	.+8      	; 0x10bc <xTaskIncrementTick+0xd4>
    10b4:	c7 01       	movw	r24, r14
    10b6:	0c 96       	adiw	r24, 0x0c	; 12
    10b8:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    10bc:	d7 01       	movw	r26, r14
    10be:	56 96       	adiw	r26, 0x16	; 22
    10c0:	8c 91       	ld	r24, X
    10c2:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <uxTopReadyPriority>
    10c6:	98 17       	cp	r25, r24
    10c8:	10 f4       	brcc	.+4      	; 0x10ce <xTaskIncrementTick+0xe6>
    10ca:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <uxTopReadyPriority>
    10ce:	d8 9f       	mul	r29, r24
    10d0:	c0 01       	movw	r24, r0
    10d2:	11 24       	eor	r1, r1
    10d4:	b6 01       	movw	r22, r12
    10d6:	83 5b       	subi	r24, 0xB3	; 179
    10d8:	9d 4f       	sbci	r25, 0xFD	; 253
    10da:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vListInsertEnd>
    10de:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
    10e2:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    10e6:	d7 01       	movw	r26, r14
    10e8:	56 96       	adiw	r26, 0x16	; 22
    10ea:	9c 91       	ld	r25, X
    10ec:	86 89       	ldd	r24, Z+22	; 0x16
    10ee:	98 17       	cp	r25, r24
    10f0:	08 f4       	brcc	.+2      	; 0x10f4 <xTaskIncrementTick+0x10c>
    10f2:	b4 cf       	rjmp	.-152    	; 0x105c <xTaskIncrementTick+0x74>
    10f4:	c1 e0       	ldi	r28, 0x01	; 1
    10f6:	b2 cf       	rjmp	.-156    	; 0x105c <xTaskIncrementTick+0x74>
    10f8:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
    10fc:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1100:	e6 89       	ldd	r30, Z+22	; 0x16
    1102:	b9 e0       	ldi	r27, 0x09	; 9
    1104:	eb 9f       	mul	r30, r27
    1106:	f0 01       	movw	r30, r0
    1108:	11 24       	eor	r1, r1
    110a:	e3 5b       	subi	r30, 0xB3	; 179
    110c:	fd 4f       	sbci	r31, 0xFD	; 253
    110e:	80 81       	ld	r24, Z
    1110:	82 30       	cpi	r24, 0x02	; 2
    1112:	08 f0       	brcs	.+2      	; 0x1116 <xTaskIncrementTick+0x12e>
    1114:	c1 e0       	ldi	r28, 0x01	; 1
    1116:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <xYieldPending>
    111a:	88 23       	and	r24, r24
    111c:	61 f0       	breq	.+24     	; 0x1136 <xTaskIncrementTick+0x14e>
    111e:	c1 e0       	ldi	r28, 0x01	; 1
    1120:	0a c0       	rjmp	.+20     	; 0x1136 <xTaskIncrementTick+0x14e>
    1122:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <xPendedTicks>
    1126:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <xPendedTicks+0x1>
    112a:	01 96       	adiw	r24, 0x01	; 1
    112c:	90 93 15 02 	sts	0x0215, r25	; 0x800215 <xPendedTicks+0x1>
    1130:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <xPendedTicks>
    1134:	c0 e0       	ldi	r28, 0x00	; 0
    1136:	8c 2f       	mov	r24, r28
    1138:	df 91       	pop	r29
    113a:	cf 91       	pop	r28
    113c:	1f 91       	pop	r17
    113e:	0f 91       	pop	r16
    1140:	ff 90       	pop	r15
    1142:	ef 90       	pop	r14
    1144:	df 90       	pop	r13
    1146:	cf 90       	pop	r12
    1148:	08 95       	ret

0000114a <xTaskResumeAll>:
    114a:	ef 92       	push	r14
    114c:	ff 92       	push	r15
    114e:	0f 93       	push	r16
    1150:	1f 93       	push	r17
    1152:	cf 93       	push	r28
    1154:	df 93       	push	r29
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	f8 94       	cli
    115a:	0f 92       	push	r0
    115c:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
    1160:	81 50       	subi	r24, 0x01	; 1
    1162:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <uxSchedulerSuspended>
    1166:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
    116a:	88 23       	and	r24, r24
    116c:	11 f0       	breq	.+4      	; 0x1172 <xTaskResumeAll+0x28>
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	56 c0       	rjmp	.+172    	; 0x121e <xTaskResumeAll+0xd4>
    1172:	80 91 1a 02 	lds	r24, 0x021A	; 0x80021a <uxCurrentNumberOfTasks>
    1176:	88 23       	and	r24, r24
    1178:	d1 f3       	breq	.-12     	; 0x116e <xTaskResumeAll+0x24>
    117a:	c0 e0       	ldi	r28, 0x00	; 0
    117c:	d0 e0       	ldi	r29, 0x00	; 0
    117e:	89 e0       	ldi	r24, 0x09	; 9
    1180:	f8 2e       	mov	r15, r24
    1182:	ee 24       	eor	r14, r14
    1184:	e3 94       	inc	r14
    1186:	80 91 2e 02 	lds	r24, 0x022E	; 0x80022e <xPendingReadyList>
    118a:	88 23       	and	r24, r24
    118c:	51 f1       	breq	.+84     	; 0x11e2 <xTaskResumeAll+0x98>
    118e:	e0 91 33 02 	lds	r30, 0x0233	; 0x800233 <xPendingReadyList+0x5>
    1192:	f0 91 34 02 	lds	r31, 0x0234	; 0x800234 <xPendingReadyList+0x6>
    1196:	c6 81       	ldd	r28, Z+6	; 0x06
    1198:	d7 81       	ldd	r29, Z+7	; 0x07
    119a:	ce 01       	movw	r24, r28
    119c:	0c 96       	adiw	r24, 0x0c	; 12
    119e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    11a2:	8e 01       	movw	r16, r28
    11a4:	0e 5f       	subi	r16, 0xFE	; 254
    11a6:	1f 4f       	sbci	r17, 0xFF	; 255
    11a8:	c8 01       	movw	r24, r16
    11aa:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    11ae:	8e 89       	ldd	r24, Y+22	; 0x16
    11b0:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <uxTopReadyPriority>
    11b4:	98 17       	cp	r25, r24
    11b6:	10 f4       	brcc	.+4      	; 0x11bc <xTaskResumeAll+0x72>
    11b8:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <uxTopReadyPriority>
    11bc:	f8 9e       	mul	r15, r24
    11be:	c0 01       	movw	r24, r0
    11c0:	11 24       	eor	r1, r1
    11c2:	b8 01       	movw	r22, r16
    11c4:	83 5b       	subi	r24, 0xB3	; 179
    11c6:	9d 4f       	sbci	r25, 0xFD	; 253
    11c8:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vListInsertEnd>
    11cc:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
    11d0:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    11d4:	9e 89       	ldd	r25, Y+22	; 0x16
    11d6:	86 89       	ldd	r24, Z+22	; 0x16
    11d8:	98 17       	cp	r25, r24
    11da:	a8 f2       	brcs	.-86     	; 0x1186 <xTaskResumeAll+0x3c>
    11dc:	e0 92 13 02 	sts	0x0213, r14	; 0x800213 <xYieldPending>
    11e0:	d2 cf       	rjmp	.-92     	; 0x1186 <xTaskResumeAll+0x3c>
    11e2:	cd 2b       	or	r28, r29
    11e4:	11 f0       	breq	.+4      	; 0x11ea <xTaskResumeAll+0xa0>
    11e6:	0e 94 05 06 	call	0xc0a	; 0xc0a <prvResetNextTaskUnblockTime>
    11ea:	c0 91 14 02 	lds	r28, 0x0214	; 0x800214 <xPendedTicks>
    11ee:	d0 91 15 02 	lds	r29, 0x0215	; 0x800215 <xPendedTicks+0x1>
    11f2:	20 97       	sbiw	r28, 0x00	; 0
    11f4:	61 f0       	breq	.+24     	; 0x120e <xTaskResumeAll+0xc4>
    11f6:	11 e0       	ldi	r17, 0x01	; 1
    11f8:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <xTaskIncrementTick>
    11fc:	81 11       	cpse	r24, r1
    11fe:	10 93 13 02 	sts	0x0213, r17	; 0x800213 <xYieldPending>
    1202:	21 97       	sbiw	r28, 0x01	; 1
    1204:	c9 f7       	brne	.-14     	; 0x11f8 <xTaskResumeAll+0xae>
    1206:	10 92 15 02 	sts	0x0215, r1	; 0x800215 <xPendedTicks+0x1>
    120a:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <xPendedTicks>
    120e:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <xYieldPending>
    1212:	88 23       	and	r24, r24
    1214:	09 f4       	brne	.+2      	; 0x1218 <xTaskResumeAll+0xce>
    1216:	ab cf       	rjmp	.-170    	; 0x116e <xTaskResumeAll+0x24>
    1218:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    121c:	81 e0       	ldi	r24, 0x01	; 1
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	df 91       	pop	r29
    1224:	cf 91       	pop	r28
    1226:	1f 91       	pop	r17
    1228:	0f 91       	pop	r16
    122a:	ff 90       	pop	r15
    122c:	ef 90       	pop	r14
    122e:	08 95       	ret

00001230 <vTaskDelayUntil>:
    1230:	0f 93       	push	r16
    1232:	1f 93       	push	r17
    1234:	cf 93       	push	r28
    1236:	df 93       	push	r29
    1238:	8c 01       	movw	r16, r24
    123a:	eb 01       	movw	r28, r22
    123c:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vTaskSuspendAll>
    1240:	40 91 18 02 	lds	r20, 0x0218	; 0x800218 <xTickCount>
    1244:	50 91 19 02 	lds	r21, 0x0219	; 0x800219 <xTickCount+0x1>
    1248:	f8 01       	movw	r30, r16
    124a:	20 81       	ld	r18, Z
    124c:	31 81       	ldd	r19, Z+1	; 0x01
    124e:	c9 01       	movw	r24, r18
    1250:	8c 0f       	add	r24, r28
    1252:	9d 1f       	adc	r25, r29
    1254:	42 17       	cp	r20, r18
    1256:	53 07       	cpc	r21, r19
    1258:	20 f4       	brcc	.+8      	; 0x1262 <vTaskDelayUntil+0x32>
    125a:	82 17       	cp	r24, r18
    125c:	93 07       	cpc	r25, r19
    125e:	40 f4       	brcc	.+16     	; 0x1270 <vTaskDelayUntil+0x40>
    1260:	03 c0       	rjmp	.+6      	; 0x1268 <vTaskDelayUntil+0x38>
    1262:	82 17       	cp	r24, r18
    1264:	93 07       	cpc	r25, r19
    1266:	30 f0       	brcs	.+12     	; 0x1274 <vTaskDelayUntil+0x44>
    1268:	21 e0       	ldi	r18, 0x01	; 1
    126a:	48 17       	cp	r20, r24
    126c:	59 07       	cpc	r21, r25
    126e:	18 f0       	brcs	.+6      	; 0x1276 <vTaskDelayUntil+0x46>
    1270:	20 e0       	ldi	r18, 0x00	; 0
    1272:	01 c0       	rjmp	.+2      	; 0x1276 <vTaskDelayUntil+0x46>
    1274:	21 e0       	ldi	r18, 0x01	; 1
    1276:	f8 01       	movw	r30, r16
    1278:	91 83       	std	Z+1, r25	; 0x01
    127a:	80 83       	st	Z, r24
    127c:	22 23       	and	r18, r18
    127e:	29 f0       	breq	.+10     	; 0x128a <vTaskDelayUntil+0x5a>
    1280:	60 e0       	ldi	r22, 0x00	; 0
    1282:	84 1b       	sub	r24, r20
    1284:	95 0b       	sbc	r25, r21
    1286:	0e 94 20 06 	call	0xc40	; 0xc40 <prvAddCurrentTaskToDelayedList>
    128a:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    128e:	81 11       	cpse	r24, r1
    1290:	02 c0       	rjmp	.+4      	; 0x1296 <vTaskDelayUntil+0x66>
    1292:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    1296:	df 91       	pop	r29
    1298:	cf 91       	pop	r28
    129a:	1f 91       	pop	r17
    129c:	0f 91       	pop	r16
    129e:	08 95       	ret

000012a0 <vTaskSwitchContext>:
    12a0:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
    12a4:	88 23       	and	r24, r24
    12a6:	21 f0       	breq	.+8      	; 0x12b0 <vTaskSwitchContext+0x10>
    12a8:	81 e0       	ldi	r24, 0x01	; 1
    12aa:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <xYieldPending>
    12ae:	08 95       	ret
    12b0:	10 92 13 02 	sts	0x0213, r1	; 0x800213 <xYieldPending>
    12b4:	a0 91 71 02 	lds	r26, 0x0271	; 0x800271 <pxCurrentTCB>
    12b8:	b0 91 72 02 	lds	r27, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    12bc:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
    12c0:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    12c4:	2d 91       	ld	r18, X+
    12c6:	3c 91       	ld	r19, X
    12c8:	87 89       	ldd	r24, Z+23	; 0x17
    12ca:	90 8d       	ldd	r25, Z+24	; 0x18
    12cc:	82 17       	cp	r24, r18
    12ce:	93 07       	cpc	r25, r19
    12d0:	60 f0       	brcs	.+24     	; 0x12ea <vTaskSwitchContext+0x4a>
    12d2:	60 91 71 02 	lds	r22, 0x0271	; 0x800271 <pxCurrentTCB>
    12d6:	70 91 72 02 	lds	r23, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    12da:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <pxCurrentTCB>
    12de:	90 91 72 02 	lds	r25, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    12e2:	67 5e       	subi	r22, 0xE7	; 231
    12e4:	7f 4f       	sbci	r23, 0xFF	; 255
    12e6:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vApplicationStackOverflowHook>
    12ea:	80 91 17 02 	lds	r24, 0x0217	; 0x800217 <uxTopReadyPriority>
    12ee:	69 e0       	ldi	r22, 0x09	; 9
    12f0:	48 2f       	mov	r20, r24
    12f2:	50 e0       	ldi	r21, 0x00	; 0
    12f4:	64 9f       	mul	r22, r20
    12f6:	90 01       	movw	r18, r0
    12f8:	65 9f       	mul	r22, r21
    12fa:	30 0d       	add	r19, r0
    12fc:	11 24       	eor	r1, r1
    12fe:	f9 01       	movw	r30, r18
    1300:	e3 5b       	subi	r30, 0xB3	; 179
    1302:	fd 4f       	sbci	r31, 0xFD	; 253
    1304:	90 81       	ld	r25, Z
    1306:	91 11       	cpse	r25, r1
    1308:	02 c0       	rjmp	.+4      	; 0x130e <vTaskSwitchContext+0x6e>
    130a:	81 50       	subi	r24, 0x01	; 1
    130c:	f1 cf       	rjmp	.-30     	; 0x12f0 <vTaskSwitchContext+0x50>
    130e:	a1 81       	ldd	r26, Z+1	; 0x01
    1310:	b2 81       	ldd	r27, Z+2	; 0x02
    1312:	12 96       	adiw	r26, 0x02	; 2
    1314:	0d 90       	ld	r0, X+
    1316:	bc 91       	ld	r27, X
    1318:	a0 2d       	mov	r26, r0
    131a:	b2 83       	std	Z+2, r27	; 0x02
    131c:	a1 83       	std	Z+1, r26	; 0x01
    131e:	20 5b       	subi	r18, 0xB0	; 176
    1320:	3d 4f       	sbci	r19, 0xFD	; 253
    1322:	a2 17       	cp	r26, r18
    1324:	b3 07       	cpc	r27, r19
    1326:	31 f4       	brne	.+12     	; 0x1334 <vTaskSwitchContext+0x94>
    1328:	12 96       	adiw	r26, 0x02	; 2
    132a:	2d 91       	ld	r18, X+
    132c:	3c 91       	ld	r19, X
    132e:	13 97       	sbiw	r26, 0x03	; 3
    1330:	32 83       	std	Z+2, r19	; 0x02
    1332:	21 83       	std	Z+1, r18	; 0x01
    1334:	99 e0       	ldi	r25, 0x09	; 9
    1336:	94 9f       	mul	r25, r20
    1338:	f0 01       	movw	r30, r0
    133a:	95 9f       	mul	r25, r21
    133c:	f0 0d       	add	r31, r0
    133e:	11 24       	eor	r1, r1
    1340:	e3 5b       	subi	r30, 0xB3	; 179
    1342:	fd 4f       	sbci	r31, 0xFD	; 253
    1344:	01 80       	ldd	r0, Z+1	; 0x01
    1346:	f2 81       	ldd	r31, Z+2	; 0x02
    1348:	e0 2d       	mov	r30, r0
    134a:	26 81       	ldd	r18, Z+6	; 0x06
    134c:	37 81       	ldd	r19, Z+7	; 0x07
    134e:	30 93 72 02 	sts	0x0272, r19	; 0x800272 <pxCurrentTCB+0x1>
    1352:	20 93 71 02 	sts	0x0271, r18	; 0x800271 <pxCurrentTCB>
    1356:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <uxTopReadyPriority>
    135a:	08 95       	ret

0000135c <vTaskPlaceOnEventList>:
    135c:	cf 93       	push	r28
    135e:	df 93       	push	r29
    1360:	eb 01       	movw	r28, r22
    1362:	60 91 71 02 	lds	r22, 0x0271	; 0x800271 <pxCurrentTCB>
    1366:	70 91 72 02 	lds	r23, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    136a:	64 5f       	subi	r22, 0xF4	; 244
    136c:	7f 4f       	sbci	r23, 0xFF	; 255
    136e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vListInsert>
    1372:	61 e0       	ldi	r22, 0x01	; 1
    1374:	ce 01       	movw	r24, r28
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	0c 94 20 06 	jmp	0xc40	; 0xc40 <prvAddCurrentTaskToDelayedList>

0000137e <vTaskPlaceOnEventListRestricted>:
    137e:	1f 93       	push	r17
    1380:	cf 93       	push	r28
    1382:	df 93       	push	r29
    1384:	eb 01       	movw	r28, r22
    1386:	14 2f       	mov	r17, r20
    1388:	60 91 71 02 	lds	r22, 0x0271	; 0x800271 <pxCurrentTCB>
    138c:	70 91 72 02 	lds	r23, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1390:	64 5f       	subi	r22, 0xF4	; 244
    1392:	7f 4f       	sbci	r23, 0xFF	; 255
    1394:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vListInsertEnd>
    1398:	11 23       	and	r17, r17
    139a:	11 f0       	breq	.+4      	; 0x13a0 <vTaskPlaceOnEventListRestricted+0x22>
    139c:	cf ef       	ldi	r28, 0xFF	; 255
    139e:	df ef       	ldi	r29, 0xFF	; 255
    13a0:	61 2f       	mov	r22, r17
    13a2:	ce 01       	movw	r24, r28
    13a4:	df 91       	pop	r29
    13a6:	cf 91       	pop	r28
    13a8:	1f 91       	pop	r17
    13aa:	0c 94 20 06 	jmp	0xc40	; 0xc40 <prvAddCurrentTaskToDelayedList>

000013ae <xTaskRemoveFromEventList>:
    13ae:	0f 93       	push	r16
    13b0:	1f 93       	push	r17
    13b2:	cf 93       	push	r28
    13b4:	df 93       	push	r29
    13b6:	dc 01       	movw	r26, r24
    13b8:	15 96       	adiw	r26, 0x05	; 5
    13ba:	ed 91       	ld	r30, X+
    13bc:	fc 91       	ld	r31, X
    13be:	16 97       	sbiw	r26, 0x06	; 6
    13c0:	c6 81       	ldd	r28, Z+6	; 0x06
    13c2:	d7 81       	ldd	r29, Z+7	; 0x07
    13c4:	8e 01       	movw	r16, r28
    13c6:	04 5f       	subi	r16, 0xF4	; 244
    13c8:	1f 4f       	sbci	r17, 0xFF	; 255
    13ca:	c8 01       	movw	r24, r16
    13cc:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    13d0:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
    13d4:	81 11       	cpse	r24, r1
    13d6:	14 c0       	rjmp	.+40     	; 0x1400 <xTaskRemoveFromEventList+0x52>
    13d8:	0a 50       	subi	r16, 0x0A	; 10
    13da:	11 09       	sbc	r17, r1
    13dc:	c8 01       	movw	r24, r16
    13de:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    13e2:	8e 89       	ldd	r24, Y+22	; 0x16
    13e4:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <uxTopReadyPriority>
    13e8:	98 17       	cp	r25, r24
    13ea:	10 f4       	brcc	.+4      	; 0x13f0 <xTaskRemoveFromEventList+0x42>
    13ec:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <uxTopReadyPriority>
    13f0:	b9 e0       	ldi	r27, 0x09	; 9
    13f2:	8b 9f       	mul	r24, r27
    13f4:	c0 01       	movw	r24, r0
    13f6:	11 24       	eor	r1, r1
    13f8:	b8 01       	movw	r22, r16
    13fa:	83 5b       	subi	r24, 0xB3	; 179
    13fc:	9d 4f       	sbci	r25, 0xFD	; 253
    13fe:	03 c0       	rjmp	.+6      	; 0x1406 <xTaskRemoveFromEventList+0x58>
    1400:	b8 01       	movw	r22, r16
    1402:	8e e2       	ldi	r24, 0x2E	; 46
    1404:	92 e0       	ldi	r25, 0x02	; 2
    1406:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vListInsertEnd>
    140a:	e0 91 71 02 	lds	r30, 0x0271	; 0x800271 <pxCurrentTCB>
    140e:	f0 91 72 02 	lds	r31, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1412:	9e 89       	ldd	r25, Y+22	; 0x16
    1414:	86 89       	ldd	r24, Z+22	; 0x16
    1416:	89 17       	cp	r24, r25
    1418:	20 f4       	brcc	.+8      	; 0x1422 <xTaskRemoveFromEventList+0x74>
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <xYieldPending>
    1420:	01 c0       	rjmp	.+2      	; 0x1424 <xTaskRemoveFromEventList+0x76>
    1422:	80 e0       	ldi	r24, 0x00	; 0
    1424:	df 91       	pop	r29
    1426:	cf 91       	pop	r28
    1428:	1f 91       	pop	r17
    142a:	0f 91       	pop	r16
    142c:	08 95       	ret

0000142e <vTaskInternalSetTimeOutState>:
    142e:	20 91 12 02 	lds	r18, 0x0212	; 0x800212 <xNumOfOverflows>
    1432:	fc 01       	movw	r30, r24
    1434:	20 83       	st	Z, r18
    1436:	20 91 18 02 	lds	r18, 0x0218	; 0x800218 <xTickCount>
    143a:	30 91 19 02 	lds	r19, 0x0219	; 0x800219 <xTickCount+0x1>
    143e:	32 83       	std	Z+2, r19	; 0x02
    1440:	21 83       	std	Z+1, r18	; 0x01
    1442:	08 95       	ret

00001444 <xTaskCheckForTimeOut>:
    1444:	cf 93       	push	r28
    1446:	df 93       	push	r29
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
    144e:	40 91 18 02 	lds	r20, 0x0218	; 0x800218 <xTickCount>
    1452:	50 91 19 02 	lds	r21, 0x0219	; 0x800219 <xTickCount+0x1>
    1456:	db 01       	movw	r26, r22
    1458:	2d 91       	ld	r18, X+
    145a:	3c 91       	ld	r19, X
    145c:	2f 3f       	cpi	r18, 0xFF	; 255
    145e:	bf ef       	ldi	r27, 0xFF	; 255
    1460:	3b 07       	cpc	r19, r27
    1462:	d9 f0       	breq	.+54     	; 0x149a <xTaskCheckForTimeOut+0x56>
    1464:	ec 01       	movw	r28, r24
    1466:	e9 81       	ldd	r30, Y+1	; 0x01
    1468:	fa 81       	ldd	r31, Y+2	; 0x02
    146a:	a0 91 12 02 	lds	r26, 0x0212	; 0x800212 <xNumOfOverflows>
    146e:	b8 81       	ld	r27, Y
    1470:	ba 17       	cp	r27, r26
    1472:	19 f0       	breq	.+6      	; 0x147a <xTaskCheckForTimeOut+0x36>
    1474:	4e 17       	cp	r20, r30
    1476:	5f 07       	cpc	r21, r31
    1478:	90 f4       	brcc	.+36     	; 0x149e <xTaskCheckForTimeOut+0x5a>
    147a:	4e 1b       	sub	r20, r30
    147c:	5f 0b       	sbc	r21, r31
    147e:	fb 01       	movw	r30, r22
    1480:	42 17       	cp	r20, r18
    1482:	53 07       	cpc	r21, r19
    1484:	38 f4       	brcc	.+14     	; 0x1494 <xTaskCheckForTimeOut+0x50>
    1486:	24 1b       	sub	r18, r20
    1488:	35 0b       	sbc	r19, r21
    148a:	31 83       	std	Z+1, r19	; 0x01
    148c:	20 83       	st	Z, r18
    148e:	0e 94 17 0a 	call	0x142e	; 0x142e <vTaskInternalSetTimeOutState>
    1492:	03 c0       	rjmp	.+6      	; 0x149a <xTaskCheckForTimeOut+0x56>
    1494:	11 82       	std	Z+1, r1	; 0x01
    1496:	10 82       	st	Z, r1
    1498:	02 c0       	rjmp	.+4      	; 0x149e <xTaskCheckForTimeOut+0x5a>
    149a:	80 e0       	ldi	r24, 0x00	; 0
    149c:	01 c0       	rjmp	.+2      	; 0x14a0 <xTaskCheckForTimeOut+0x5c>
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	0f 90       	pop	r0
    14a2:	0f be       	out	0x3f, r0	; 63
    14a4:	df 91       	pop	r29
    14a6:	cf 91       	pop	r28
    14a8:	08 95       	ret

000014aa <vTaskMissedYield>:
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <xYieldPending>
    14b0:	08 95       	ret

000014b2 <uxTaskGetStackHighWaterMark>:
    14b2:	00 97       	sbiw	r24, 0x00	; 0
    14b4:	21 f4       	brne	.+8      	; 0x14be <uxTaskGetStackHighWaterMark+0xc>
    14b6:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <pxCurrentTCB>
    14ba:	90 91 72 02 	lds	r25, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    14be:	dc 01       	movw	r26, r24
    14c0:	57 96       	adiw	r26, 0x17	; 23
    14c2:	ed 91       	ld	r30, X+
    14c4:	fc 91       	ld	r31, X
    14c6:	58 97       	sbiw	r26, 0x18	; 24
    14c8:	80 e0       	ldi	r24, 0x00	; 0
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	dc 01       	movw	r26, r24
    14ce:	21 91       	ld	r18, Z+
    14d0:	25 3a       	cpi	r18, 0xA5	; 165
    14d2:	21 f4       	brne	.+8      	; 0x14dc <uxTaskGetStackHighWaterMark+0x2a>
    14d4:	01 96       	adiw	r24, 0x01	; 1
    14d6:	a1 1d       	adc	r26, r1
    14d8:	b1 1d       	adc	r27, r1
    14da:	f9 cf       	rjmp	.-14     	; 0x14ce <uxTaskGetStackHighWaterMark+0x1c>
    14dc:	08 95       	ret

000014de <xTaskGetSchedulerState>:
    14de:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <xSchedulerRunning>
    14e2:	88 23       	and	r24, r24
    14e4:	31 f0       	breq	.+12     	; 0x14f2 <xTaskGetSchedulerState+0x14>
    14e6:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <uxSchedulerSuspended>
    14ea:	88 23       	and	r24, r24
    14ec:	21 f0       	breq	.+8      	; 0x14f6 <xTaskGetSchedulerState+0x18>
    14ee:	80 e0       	ldi	r24, 0x00	; 0
    14f0:	08 95       	ret
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	08 95       	ret
    14f6:	82 e0       	ldi	r24, 0x02	; 2
    14f8:	08 95       	ret

000014fa <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    14fa:	0f 93       	push	r16
    14fc:	1f 93       	push	r17
    14fe:	cf 93       	push	r28
    1500:	df 93       	push	r29
    1502:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    1504:	89 2b       	or	r24, r25
    1506:	11 f4       	brne	.+4      	; 0x150c <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	2c c0       	rjmp	.+88     	; 0x1564 <xTaskPriorityDisinherit+0x6a>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    150c:	82 a1       	ldd	r24, Z+34	; 0x22
    150e:	81 50       	subi	r24, 0x01	; 1
    1510:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1512:	26 89       	ldd	r18, Z+22	; 0x16
    1514:	91 a1       	ldd	r25, Z+33	; 0x21
    1516:	29 17       	cp	r18, r25
    1518:	b9 f3       	breq	.-18     	; 0x1508 <xTaskPriorityDisinherit+0xe>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    151a:	81 11       	cpse	r24, r1
    151c:	f5 cf       	rjmp	.-22     	; 0x1508 <xTaskPriorityDisinherit+0xe>
    151e:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready/delayed list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1520:	8f 01       	movw	r16, r30
    1522:	0e 5f       	subi	r16, 0xFE	; 254
    1524:	1f 4f       	sbci	r17, 0xFF	; 255
    1526:	c8 01       	movw	r24, r16
    1528:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    152c:	89 a1       	ldd	r24, Y+33	; 0x21
    152e:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1530:	48 2f       	mov	r20, r24
    1532:	50 e0       	ldi	r21, 0x00	; 0
    1534:	24 e0       	ldi	r18, 0x04	; 4
    1536:	30 e0       	ldi	r19, 0x00	; 0
    1538:	24 1b       	sub	r18, r20
    153a:	35 0b       	sbc	r19, r21
    153c:	3d 87       	std	Y+13, r19	; 0x0d
    153e:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    1540:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <uxTopReadyPriority>
    1544:	98 17       	cp	r25, r24
    1546:	10 f4       	brcc	.+4      	; 0x154c <xTaskPriorityDisinherit+0x52>
    1548:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <uxTopReadyPriority>
    154c:	29 e0       	ldi	r18, 0x09	; 9
    154e:	24 9f       	mul	r18, r20
    1550:	c0 01       	movw	r24, r0
    1552:	25 9f       	mul	r18, r21
    1554:	90 0d       	add	r25, r0
    1556:	11 24       	eor	r1, r1
    1558:	b8 01       	movw	r22, r16
    155a:	83 5b       	subi	r24, 0xB3	; 179
    155c:	9d 4f       	sbci	r25, 0xFD	; 253
    155e:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    1562:	81 e0       	ldi	r24, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	1f 91       	pop	r17
    156a:	0f 91       	pop	r16
    156c:	08 95       	ret

0000156e <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
    1574:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <xTimerQueue>
    1578:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <xTimerQueue+0x1>
    157c:	89 2b       	or	r24, r25
    157e:	e9 f4       	brne	.+58     	; 0x15ba <prvCheckForValidListAndQueue+0x4c>
    1580:	86 e8       	ldi	r24, 0x86	; 134
    1582:	92 e0       	ldi	r25, 0x02	; 2
    1584:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
    1588:	8d e7       	ldi	r24, 0x7D	; 125
    158a:	92 e0       	ldi	r25, 0x02	; 2
    158c:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
    1590:	86 e8       	ldi	r24, 0x86	; 134
    1592:	92 e0       	ldi	r25, 0x02	; 2
    1594:	90 93 7c 02 	sts	0x027C, r25	; 0x80027c <pxCurrentTimerList+0x1>
    1598:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <pxCurrentTimerList>
    159c:	8d e7       	ldi	r24, 0x7D	; 125
    159e:	92 e0       	ldi	r25, 0x02	; 2
    15a0:	90 93 7a 02 	sts	0x027A, r25	; 0x80027a <pxOverflowTimerList+0x1>
    15a4:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <pxOverflowTimerList>
    15a8:	40 e0       	ldi	r20, 0x00	; 0
    15aa:	65 e0       	ldi	r22, 0x05	; 5
    15ac:	8a e0       	ldi	r24, 0x0A	; 10
    15ae:	0e 94 9c 0f 	call	0x1f38	; 0x1f38 <xQueueGenericCreate>
    15b2:	90 93 78 02 	sts	0x0278, r25	; 0x800278 <xTimerQueue+0x1>
    15b6:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <xTimerQueue>
    15ba:	0f 90       	pop	r0
    15bc:	0f be       	out	0x3f, r0	; 63
    15be:	08 95       	ret

000015c0 <prvInsertTimerInActiveList>:
    15c0:	fc 01       	movw	r30, r24
    15c2:	73 83       	std	Z+3, r23	; 0x03
    15c4:	62 83       	std	Z+2, r22	; 0x02
    15c6:	91 87       	std	Z+9, r25	; 0x09
    15c8:	80 87       	std	Z+8, r24	; 0x08
    15ca:	46 17       	cp	r20, r22
    15cc:	57 07       	cpc	r21, r23
    15ce:	78 f0       	brcs	.+30     	; 0x15ee <prvInsertTimerInActiveList+0x2e>
    15d0:	42 1b       	sub	r20, r18
    15d2:	53 0b       	sbc	r21, r19
    15d4:	84 85       	ldd	r24, Z+12	; 0x0c
    15d6:	95 85       	ldd	r25, Z+13	; 0x0d
    15d8:	48 17       	cp	r20, r24
    15da:	59 07       	cpc	r21, r25
    15dc:	c8 f4       	brcc	.+50     	; 0x1610 <prvInsertTimerInActiveList+0x50>
    15de:	bf 01       	movw	r22, r30
    15e0:	6e 5f       	subi	r22, 0xFE	; 254
    15e2:	7f 4f       	sbci	r23, 0xFF	; 255
    15e4:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <pxOverflowTimerList>
    15e8:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <pxOverflowTimerList+0x1>
    15ec:	0d c0       	rjmp	.+26     	; 0x1608 <prvInsertTimerInActiveList+0x48>
    15ee:	42 17       	cp	r20, r18
    15f0:	53 07       	cpc	r21, r19
    15f2:	18 f4       	brcc	.+6      	; 0x15fa <prvInsertTimerInActiveList+0x3a>
    15f4:	62 17       	cp	r22, r18
    15f6:	73 07       	cpc	r23, r19
    15f8:	58 f4       	brcc	.+22     	; 0x1610 <prvInsertTimerInActiveList+0x50>
    15fa:	bf 01       	movw	r22, r30
    15fc:	6e 5f       	subi	r22, 0xFE	; 254
    15fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1600:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <pxCurrentTimerList>
    1604:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <pxCurrentTimerList+0x1>
    1608:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vListInsert>
    160c:	80 e0       	ldi	r24, 0x00	; 0
    160e:	08 95       	ret
    1610:	81 e0       	ldi	r24, 0x01	; 1
    1612:	08 95       	ret

00001614 <xTimerCreateTimerTask>:
    1614:	ef 92       	push	r14
    1616:	ff 92       	push	r15
    1618:	0f 93       	push	r16
    161a:	0e 94 b7 0a 	call	0x156e	; 0x156e <prvCheckForValidListAndQueue>
    161e:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <xTimerQueue>
    1622:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <xTimerQueue+0x1>
    1626:	89 2b       	or	r24, r25
    1628:	81 f0       	breq	.+32     	; 0x164a <xTimerCreateTimerTask+0x36>
    162a:	85 e7       	ldi	r24, 0x75	; 117
    162c:	e8 2e       	mov	r14, r24
    162e:	82 e0       	ldi	r24, 0x02	; 2
    1630:	f8 2e       	mov	r15, r24
    1632:	03 e0       	ldi	r16, 0x03	; 3
    1634:	20 e0       	ldi	r18, 0x00	; 0
    1636:	30 e0       	ldi	r19, 0x00	; 0
    1638:	45 e5       	ldi	r20, 0x55	; 85
    163a:	50 e0       	ldi	r21, 0x00	; 0
    163c:	66 e5       	ldi	r22, 0x56	; 86
    163e:	71 e0       	ldi	r23, 0x01	; 1
    1640:	8a eb       	ldi	r24, 0xBA	; 186
    1642:	9b e0       	ldi	r25, 0x0B	; 11
    1644:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskCreate>
    1648:	01 c0       	rjmp	.+2      	; 0x164c <xTimerCreateTimerTask+0x38>
    164a:	80 e0       	ldi	r24, 0x00	; 0
    164c:	0f 91       	pop	r16
    164e:	ff 90       	pop	r15
    1650:	ef 90       	pop	r14
    1652:	08 95       	ret

00001654 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	00 d0       	rcall	.+0      	; 0x165e <xTimerGenericCommand+0xa>
    165e:	00 d0       	rcall	.+0      	; 0x1660 <xTimerGenericCommand+0xc>
    1660:	1f 92       	push	r1
    1662:	cd b7       	in	r28, 0x3d	; 61
    1664:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    1666:	a0 91 77 02 	lds	r26, 0x0277	; 0x800277 <xTimerQueue>
    166a:	b0 91 78 02 	lds	r27, 0x0278	; 0x800278 <xTimerQueue+0x1>
    166e:	10 97       	sbiw	r26, 0x00	; 0
    1670:	29 f1       	breq	.+74     	; 0x16bc <xTimerGenericCommand+0x68>
    1672:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    1674:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1676:	5b 83       	std	Y+3, r21	; 0x03
    1678:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    167a:	9d 83       	std	Y+5, r25	; 0x05
    167c:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    167e:	66 30       	cpi	r22, 0x06	; 6
    1680:	a4 f4       	brge	.+40     	; 0x16aa <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1682:	0e 94 6f 0a 	call	0x14de	; 0x14de <xTaskGetSchedulerState>
    1686:	e0 91 77 02 	lds	r30, 0x0277	; 0x800277 <xTimerQueue>
    168a:	f0 91 78 02 	lds	r31, 0x0278	; 0x800278 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    168e:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1690:	82 30       	cpi	r24, 0x02	; 2
    1692:	11 f4       	brne	.+4      	; 0x1698 <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1694:	a8 01       	movw	r20, r16
    1696:	02 c0       	rjmp	.+4      	; 0x169c <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1698:	40 e0       	ldi	r20, 0x00	; 0
    169a:	50 e0       	ldi	r21, 0x00	; 0
    169c:	be 01       	movw	r22, r28
    169e:	6f 5f       	subi	r22, 0xFF	; 255
    16a0:	7f 4f       	sbci	r23, 0xFF	; 255
    16a2:	cf 01       	movw	r24, r30
    16a4:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xQueueGenericSend>
    16a8:	0a c0       	rjmp	.+20     	; 0x16be <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    16aa:	20 e0       	ldi	r18, 0x00	; 0
    16ac:	af 01       	movw	r20, r30
    16ae:	be 01       	movw	r22, r28
    16b0:	6f 5f       	subi	r22, 0xFF	; 255
    16b2:	7f 4f       	sbci	r23, 0xFF	; 255
    16b4:	cd 01       	movw	r24, r26
    16b6:	0e 94 55 10 	call	0x20aa	; 0x20aa <xQueueGenericSendFromISR>
    16ba:	01 c0       	rjmp	.+2      	; 0x16be <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    16bc:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	1f 91       	pop	r17
    16ce:	0f 91       	pop	r16
    16d0:	08 95       	ret

000016d2 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    16d2:	ef 92       	push	r14
    16d4:	ff 92       	push	r15
    16d6:	0f 93       	push	r16
    16d8:	1f 93       	push	r17
    16da:	cf 93       	push	r28
    16dc:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    16de:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxCurrentTimerList>
    16e2:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxCurrentTimerList+0x1>
    16e6:	80 81       	ld	r24, Z
    16e8:	88 23       	and	r24, r24
    16ea:	89 f1       	breq	.+98     	; 0x174e <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    16ec:	05 80       	ldd	r0, Z+5	; 0x05
    16ee:	f6 81       	ldd	r31, Z+6	; 0x06
    16f0:	e0 2d       	mov	r30, r0
    16f2:	e0 80       	ld	r14, Z
    16f4:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    16f6:	c6 81       	ldd	r28, Z+6	; 0x06
    16f8:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    16fa:	8e 01       	movw	r16, r28
    16fc:	0e 5f       	subi	r16, 0xFE	; 254
    16fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1700:	c8 01       	movw	r24, r16
    1702:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1706:	e8 89       	ldd	r30, Y+16	; 0x10
    1708:	f9 89       	ldd	r31, Y+17	; 0x11
    170a:	ce 01       	movw	r24, r28
    170c:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    170e:	8a 89       	ldd	r24, Y+18	; 0x12
    1710:	82 ff       	sbrs	r24, 2
    1712:	e5 cf       	rjmp	.-54     	; 0x16de <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1714:	8c 85       	ldd	r24, Y+12	; 0x0c
    1716:	9d 85       	ldd	r25, Y+13	; 0x0d
    1718:	8e 0d       	add	r24, r14
    171a:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    171c:	e8 16       	cp	r14, r24
    171e:	f9 06       	cpc	r15, r25
    1720:	60 f4       	brcc	.+24     	; 0x173a <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1722:	9b 83       	std	Y+3, r25	; 0x03
    1724:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1726:	d9 87       	std	Y+9, r29	; 0x09
    1728:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    172a:	b8 01       	movw	r22, r16
    172c:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <pxCurrentTimerList>
    1730:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <pxCurrentTimerList+0x1>
    1734:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vListInsert>
    1738:	d2 cf       	rjmp	.-92     	; 0x16de <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    173a:	00 e0       	ldi	r16, 0x00	; 0
    173c:	10 e0       	ldi	r17, 0x00	; 0
    173e:	20 e0       	ldi	r18, 0x00	; 0
    1740:	30 e0       	ldi	r19, 0x00	; 0
    1742:	a7 01       	movw	r20, r14
    1744:	60 e0       	ldi	r22, 0x00	; 0
    1746:	ce 01       	movw	r24, r28
    1748:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTimerGenericCommand>
    174c:	c8 cf       	rjmp	.-112    	; 0x16de <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    174e:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <pxOverflowTimerList>
    1752:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <pxOverflowTimerList+0x1>
    1756:	90 93 7c 02 	sts	0x027C, r25	; 0x80027c <pxCurrentTimerList+0x1>
    175a:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    175e:	f0 93 7a 02 	sts	0x027A, r31	; 0x80027a <pxOverflowTimerList+0x1>
    1762:	e0 93 79 02 	sts	0x0279, r30	; 0x800279 <pxOverflowTimerList>
}
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	ff 90       	pop	r15
    1770:	ef 90       	pop	r14
    1772:	08 95       	ret

00001774 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    1774:	cf 93       	push	r28
    1776:	df 93       	push	r29
    1778:	00 d0       	rcall	.+0      	; 0x177a <prvTimerTask+0x6>
    177a:	00 d0       	rcall	.+0      	; 0x177c <prvTimerTask+0x8>
    177c:	1f 92       	push	r1
    177e:	cd b7       	in	r28, 0x3d	; 61
    1780:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1782:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxCurrentTimerList>
    1786:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxCurrentTimerList+0x1>
    178a:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    178c:	dd 20       	and	r13, r13
    178e:	31 f0       	breq	.+12     	; 0x179c <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1790:	05 80       	ldd	r0, Z+5	; 0x05
    1792:	f6 81       	ldd	r31, Z+6	; 0x06
    1794:	e0 2d       	mov	r30, r0
    1796:	e0 80       	ld	r14, Z
    1798:	f1 80       	ldd	r15, Z+1	; 0x01
    179a:	02 c0       	rjmp	.+4      	; 0x17a0 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    179c:	e1 2c       	mov	r14, r1
    179e:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    17a0:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    17a4:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <xTaskGetTickCount>
    17a8:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    17aa:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <xLastTime.2437>
    17ae:	90 91 74 02 	lds	r25, 0x0274	; 0x800274 <xLastTime.2437+0x1>
    17b2:	08 17       	cp	r16, r24
    17b4:	19 07       	cpc	r17, r25
    17b6:	20 f4       	brcc	.+8      	; 0x17c0 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    17b8:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	01 c0       	rjmp	.+2      	; 0x17c2 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    17c0:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    17c2:	10 93 74 02 	sts	0x0274, r17	; 0x800274 <xLastTime.2437+0x1>
    17c6:	00 93 73 02 	sts	0x0273, r16	; 0x800273 <xLastTime.2437>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    17ca:	81 11       	cpse	r24, r1
    17cc:	55 c0       	rjmp	.+170    	; 0x1878 <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    17ce:	dd 20       	and	r13, r13
    17d0:	d9 f1       	breq	.+118    	; 0x1848 <prvTimerTask+0xd4>
    17d2:	0e 15       	cp	r16, r14
    17d4:	1f 05       	cpc	r17, r15
    17d6:	08 f4       	brcc	.+2      	; 0x17da <prvTimerTask+0x66>
    17d8:	3e c0       	rjmp	.+124    	; 0x1856 <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    17da:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    17de:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxCurrentTimerList>
    17e2:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxCurrentTimerList+0x1>
    17e6:	05 80       	ldd	r0, Z+5	; 0x05
    17e8:	f6 81       	ldd	r31, Z+6	; 0x06
    17ea:	e0 2d       	mov	r30, r0
    17ec:	c6 80       	ldd	r12, Z+6	; 0x06
    17ee:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    17f0:	c6 01       	movw	r24, r12
    17f2:	02 96       	adiw	r24, 0x02	; 2
    17f4:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto-reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    17f8:	d6 01       	movw	r26, r12
    17fa:	52 96       	adiw	r26, 0x12	; 18
    17fc:	8c 91       	ld	r24, X
    17fe:	52 97       	sbiw	r26, 0x12	; 18
    1800:	82 ff       	sbrs	r24, 2
    1802:	17 c0       	rjmp	.+46     	; 0x1832 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1804:	1c 96       	adiw	r26, 0x0c	; 12
    1806:	6d 91       	ld	r22, X+
    1808:	7c 91       	ld	r23, X
    180a:	1d 97       	sbiw	r26, 0x0d	; 13
    180c:	6e 0d       	add	r22, r14
    180e:	7f 1d       	adc	r23, r15
    1810:	97 01       	movw	r18, r14
    1812:	a8 01       	movw	r20, r16
    1814:	c6 01       	movw	r24, r12
    1816:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <prvInsertTimerInActiveList>
    181a:	88 23       	and	r24, r24
    181c:	69 f0       	breq	.+26     	; 0x1838 <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    181e:	00 e0       	ldi	r16, 0x00	; 0
    1820:	10 e0       	ldi	r17, 0x00	; 0
    1822:	20 e0       	ldi	r18, 0x00	; 0
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	a7 01       	movw	r20, r14
    1828:	60 e0       	ldi	r22, 0x00	; 0
    182a:	c6 01       	movw	r24, r12
    182c:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTimerGenericCommand>
    1830:	03 c0       	rjmp	.+6      	; 0x1838 <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1832:	8e 7f       	andi	r24, 0xFE	; 254
    1834:	f6 01       	movw	r30, r12
    1836:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1838:	d6 01       	movw	r26, r12
    183a:	50 96       	adiw	r26, 0x10	; 16
    183c:	ed 91       	ld	r30, X+
    183e:	fc 91       	ld	r31, X
    1840:	51 97       	sbiw	r26, 0x11	; 17
    1842:	c6 01       	movw	r24, r12
    1844:	09 95       	icall
    1846:	1e c0       	rjmp	.+60     	; 0x1884 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1848:	e0 91 79 02 	lds	r30, 0x0279	; 0x800279 <pxOverflowTimerList>
    184c:	f0 91 7a 02 	lds	r31, 0x027A	; 0x80027a <pxOverflowTimerList+0x1>
    1850:	80 81       	ld	r24, Z
    1852:	41 e0       	ldi	r20, 0x01	; 1
    1854:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1856:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1858:	b7 01       	movw	r22, r14
    185a:	60 1b       	sub	r22, r16
    185c:	71 0b       	sbc	r23, r17
    185e:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <xTimerQueue>
    1862:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <xTimerQueue+0x1>
    1866:	0e 94 17 11 	call	0x222e	; 0x222e <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    186a:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    186e:	81 11       	cpse	r24, r1
    1870:	09 c0       	rjmp	.+18     	; 0x1884 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    1872:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    1876:	06 c0       	rjmp	.+12     	; 0x1884 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    1878:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    187c:	03 c0       	rjmp	.+6      	; 0x1884 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    187e:	89 81       	ldd	r24, Y+1	; 0x01
    1880:	87 ff       	sbrs	r24, 7
    1882:	0e c0       	rjmp	.+28     	; 0x18a0 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1884:	40 e0       	ldi	r20, 0x00	; 0
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	be 01       	movw	r22, r28
    188a:	6f 5f       	subi	r22, 0xFF	; 255
    188c:	7f 4f       	sbci	r23, 0xFF	; 255
    188e:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <xTimerQueue>
    1892:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <xTimerQueue+0x1>
    1896:	0e 94 85 10 	call	0x210a	; 0x210a <xQueueReceive>
    189a:	81 11       	cpse	r24, r1
    189c:	f0 cf       	rjmp	.-32     	; 0x187e <prvTimerTask+0x10a>
    189e:	71 cf       	rjmp	.-286    	; 0x1782 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    18a0:	ec 80       	ldd	r14, Y+4	; 0x04
    18a2:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    18a4:	f7 01       	movw	r30, r14
    18a6:	82 85       	ldd	r24, Z+10	; 0x0a
    18a8:	93 85       	ldd	r25, Z+11	; 0x0b
    18aa:	89 2b       	or	r24, r25
    18ac:	21 f0       	breq	.+8      	; 0x18b6 <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    18ae:	c7 01       	movw	r24, r14
    18b0:	02 96       	adiw	r24, 0x02	; 2
    18b2:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    18b6:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <xTaskGetTickCount>
    18ba:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    18bc:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <xLastTime.2437>
    18c0:	90 91 74 02 	lds	r25, 0x0274	; 0x800274 <xLastTime.2437+0x1>
    18c4:	c8 16       	cp	r12, r24
    18c6:	d9 06       	cpc	r13, r25
    18c8:	10 f4       	brcc	.+4      	; 0x18ce <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    18ca:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    18ce:	d0 92 74 02 	sts	0x0274, r13	; 0x800274 <xLastTime.2437+0x1>
    18d2:	c0 92 73 02 	sts	0x0273, r12	; 0x800273 <xLastTime.2437>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    18d6:	e9 81       	ldd	r30, Y+1	; 0x01
    18d8:	0e 2e       	mov	r0, r30
    18da:	00 0c       	add	r0, r0
    18dc:	ff 0b       	sbc	r31, r31
    18de:	ea 30       	cpi	r30, 0x0A	; 10
    18e0:	f1 05       	cpc	r31, r1
    18e2:	80 f6       	brcc	.-96     	; 0x1884 <prvTimerTask+0x110>
    18e4:	ec 5c       	subi	r30, 0xCC	; 204
    18e6:	ff 4f       	sbci	r31, 0xFF	; 255
    18e8:	d7 01       	movw	r26, r14
    18ea:	52 96       	adiw	r26, 0x12	; 18
    18ec:	8c 91       	ld	r24, X
    18ee:	0c 94 55 11 	jmp	0x22aa	; 0x22aa <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    18f2:	81 60       	ori	r24, 0x01	; 1
    18f4:	f7 01       	movw	r30, r14
    18f6:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    18f8:	2a 81       	ldd	r18, Y+2	; 0x02
    18fa:	3b 81       	ldd	r19, Y+3	; 0x03
    18fc:	64 85       	ldd	r22, Z+12	; 0x0c
    18fe:	75 85       	ldd	r23, Z+13	; 0x0d
    1900:	62 0f       	add	r22, r18
    1902:	73 1f       	adc	r23, r19
    1904:	a6 01       	movw	r20, r12
    1906:	c7 01       	movw	r24, r14
    1908:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <prvInsertTimerInActiveList>
    190c:	88 23       	and	r24, r24
    190e:	09 f4       	brne	.+2      	; 0x1912 <prvTimerTask+0x19e>
    1910:	b9 cf       	rjmp	.-142    	; 0x1884 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1912:	d7 01       	movw	r26, r14
    1914:	50 96       	adiw	r26, 0x10	; 16
    1916:	ed 91       	ld	r30, X+
    1918:	fc 91       	ld	r31, X
    191a:	51 97       	sbiw	r26, 0x11	; 17
    191c:	c7 01       	movw	r24, r14
    191e:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1920:	f7 01       	movw	r30, r14
    1922:	82 89       	ldd	r24, Z+18	; 0x12
    1924:	82 ff       	sbrs	r24, 2
    1926:	ae cf       	rjmp	.-164    	; 0x1884 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1928:	4a 81       	ldd	r20, Y+2	; 0x02
    192a:	5b 81       	ldd	r21, Y+3	; 0x03
    192c:	84 85       	ldd	r24, Z+12	; 0x0c
    192e:	95 85       	ldd	r25, Z+13	; 0x0d
    1930:	48 0f       	add	r20, r24
    1932:	59 1f       	adc	r21, r25
    1934:	00 e0       	ldi	r16, 0x00	; 0
    1936:	10 e0       	ldi	r17, 0x00	; 0
    1938:	20 e0       	ldi	r18, 0x00	; 0
    193a:	30 e0       	ldi	r19, 0x00	; 0
    193c:	60 e0       	ldi	r22, 0x00	; 0
    193e:	c7 01       	movw	r24, r14
    1940:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTimerGenericCommand>
    1944:	9f cf       	rjmp	.-194    	; 0x1884 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1946:	81 60       	ori	r24, 0x01	; 1
    1948:	f7 01       	movw	r30, r14
    194a:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    194c:	6a 81       	ldd	r22, Y+2	; 0x02
    194e:	7b 81       	ldd	r23, Y+3	; 0x03
    1950:	75 87       	std	Z+13, r23	; 0x0d
    1952:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1954:	6c 0d       	add	r22, r12
    1956:	7d 1d       	adc	r23, r13
    1958:	96 01       	movw	r18, r12
    195a:	a6 01       	movw	r20, r12
    195c:	c7 01       	movw	r24, r14
    195e:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <prvInsertTimerInActiveList>
    1962:	90 cf       	rjmp	.-224    	; 0x1884 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    1964:	81 fd       	sbrc	r24, 1
    1966:	04 c0       	rjmp	.+8      	; 0x1970 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    1968:	c7 01       	movw	r24, r14
    196a:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <vPortFree>
    196e:	8a cf       	rjmp	.-236    	; 0x1884 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1970:	8e 7f       	andi	r24, 0xFE	; 254
    1972:	d7 01       	movw	r26, r14
    1974:	52 96       	adiw	r26, 0x12	; 18
    1976:	8c 93       	st	X, r24
    1978:	85 cf       	rjmp	.-246    	; 0x1884 <prvTimerTask+0x110>

0000197a <initVariant>:
void initVariant(void) __attribute__ ((OS_main));
void initVariant(void)
{
    // As the Task stacks are on heap before Task allocated heap variables,
    // the library default __malloc_heap_end = 0 doesn't work.
    __malloc_heap_end = (char *)(RAMEND - __malloc_margin);
    197a:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <__malloc_margin>
    197e:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1982:	8f ef       	ldi	r24, 0xFF	; 255
    1984:	98 e0       	ldi	r25, 0x08	; 8
    1986:	82 1b       	sub	r24, r18
    1988:	93 0b       	sbc	r25, r19
    198a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
    198e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();                    // the normal Arduino setup() function is run here.
    1992:	0e 94 b4 00 	call	0x168	; 0x168 <setup>
    vTaskStartScheduler();      // initialise and run the freeRTOS scheduler. Execution should never return here.
    1996:	0e 94 b6 07 	call	0xf6c	; 0xf6c <vTaskStartScheduler>
    199a:	08 95       	ret

0000199c <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();                     // the normal Arduino loop() function is run here.
    199c:	0e 94 0d 01 	call	0x21a	; 0x21a <loop>
    if (serialEventRun) serialEventRun();
    19a0:	85 ef       	ldi	r24, 0xF5	; 245
    19a2:	91 e0       	ldi	r25, 0x01	; 1
    19a4:	89 2b       	or	r24, r25
    19a6:	11 f0       	breq	.+4      	; 0x19ac <vApplicationIdleHook+0x10>
    19a8:	0c 94 f5 01 	jmp	0x3ea	; 0x3ea <_Z14serialEventRunv>
    19ac:	08 95       	ret

000019ae <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    19ae:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    19b0:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    19b2:	2f ef       	ldi	r18, 0xFF	; 255
    19b4:	80 e7       	ldi	r24, 0x70	; 112
    19b6:	92 e0       	ldi	r25, 0x02	; 2
    19b8:	21 50       	subi	r18, 0x01	; 1
    19ba:	80 40       	sbci	r24, 0x00	; 0
    19bc:	90 40       	sbci	r25, 0x00	; 0
    19be:	e1 f7       	brne	.-8      	; 0x19b8 <vApplicationMallocFailedHook+0xa>
    19c0:	00 c0       	rjmp	.+0      	; 0x19c2 <vApplicationMallocFailedHook+0x14>
    19c2:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    19c4:	1d 9a       	sbi	0x03, 5	; 3
    19c6:	f5 cf       	rjmp	.-22     	; 0x19b2 <vApplicationMallocFailedHook+0x4>

000019c8 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    19c8:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    19ca:	2d 9a       	sbi	0x05, 5	; 5
    19cc:	2f ef       	ldi	r18, 0xFF	; 255
    19ce:	87 ea       	ldi	r24, 0xA7	; 167
    19d0:	91 e6       	ldi	r25, 0x61	; 97
    19d2:	21 50       	subi	r18, 0x01	; 1
    19d4:	80 40       	sbci	r24, 0x00	; 0
    19d6:	90 40       	sbci	r25, 0x00	; 0
    19d8:	e1 f7       	brne	.-8      	; 0x19d2 <vApplicationStackOverflowHook+0xa>
    19da:	00 c0       	rjmp	.+0      	; 0x19dc <vApplicationStackOverflowHook+0x14>
    19dc:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    19de:	1d 9a       	sbi	0x03, 5	; 3
    19e0:	f5 cf       	rjmp	.-22     	; 0x19cc <vApplicationStackOverflowHook+0x4>

000019e2 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    19e2:	08 95       	ret

000019e4 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    19e4:	cf 93       	push	r28
    19e6:	df 93       	push	r29
    19e8:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    19ea:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    19ee:	ce 01       	movw	r24, r28
    19f0:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <malloc>
    19f4:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    19f6:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    19fa:	20 97       	sbiw	r28, 0x00	; 0
    19fc:	11 f4       	brne	.+4      	; 0x1a02 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    19fe:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    1a02:	ce 01       	movw	r24, r28
    1a04:	df 91       	pop	r29
    1a06:	cf 91       	pop	r28
    1a08:	08 95       	ret

00001a0a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a0a:	cf 93       	push	r28
    1a0c:	df 93       	push	r29
    if( pv )
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	51 f0       	breq	.+20     	; 0x1a26 <vPortFree+0x1c>
    1a12:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    1a14:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vTaskSuspendAll>
        {
            free( pv );
    1a18:	ce 01       	movw	r24, r28
    1a1a:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    1a1e:	df 91       	pop	r29
    1a20:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    1a22:	0c 94 a5 08 	jmp	0x114a	; 0x114a <xTaskResumeAll>
    }
}
    1a26:	df 91       	pop	r29
    1a28:	cf 91       	pop	r28
    1a2a:	08 95       	ret

00001a2c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1a2c:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a2e:	03 96       	adiw	r24, 0x03	; 3
    1a30:	92 83       	std	Z+2, r25	; 0x02
    1a32:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1a34:	2f ef       	ldi	r18, 0xFF	; 255
    1a36:	3f ef       	ldi	r19, 0xFF	; 255
    1a38:	34 83       	std	Z+4, r19	; 0x04
    1a3a:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a3c:	96 83       	std	Z+6, r25	; 0x06
    1a3e:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1a40:	90 87       	std	Z+8, r25	; 0x08
    1a42:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1a44:	10 82       	st	Z, r1
    1a46:	08 95       	ret

00001a48 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1a48:	fc 01       	movw	r30, r24
    1a4a:	11 86       	std	Z+9, r1	; 0x09
    1a4c:	10 86       	std	Z+8, r1	; 0x08
    1a4e:	08 95       	ret

00001a50 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	9c 01       	movw	r18, r24
    1a56:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1a58:	dc 01       	movw	r26, r24
    1a5a:	11 96       	adiw	r26, 0x01	; 1
    1a5c:	cd 91       	ld	r28, X+
    1a5e:	dc 91       	ld	r29, X
    1a60:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1a62:	d3 83       	std	Z+3, r29	; 0x03
    1a64:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1a66:	8c 81       	ldd	r24, Y+4	; 0x04
    1a68:	9d 81       	ldd	r25, Y+5	; 0x05
    1a6a:	95 83       	std	Z+5, r25	; 0x05
    1a6c:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1a6e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a70:	9d 81       	ldd	r25, Y+5	; 0x05
    1a72:	dc 01       	movw	r26, r24
    1a74:	13 96       	adiw	r26, 0x03	; 3
    1a76:	7c 93       	st	X, r23
    1a78:	6e 93       	st	-X, r22
    1a7a:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1a7c:	7d 83       	std	Y+5, r23	; 0x05
    1a7e:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1a80:	31 87       	std	Z+9, r19	; 0x09
    1a82:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1a84:	f9 01       	movw	r30, r18
    1a86:	80 81       	ld	r24, Z
    1a88:	8f 5f       	subi	r24, 0xFF	; 255
    1a8a:	80 83       	st	Z, r24
}
    1a8c:	df 91       	pop	r29
    1a8e:	cf 91       	pop	r28
    1a90:	08 95       	ret

00001a92 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1a92:	0f 93       	push	r16
    1a94:	1f 93       	push	r17
    1a96:	cf 93       	push	r28
    1a98:	df 93       	push	r29
    1a9a:	8c 01       	movw	r16, r24
    1a9c:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1a9e:	80 81       	ld	r24, Z
    1aa0:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1aa2:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa4:	2f ef       	ldi	r18, 0xFF	; 255
    1aa6:	92 07       	cpc	r25, r18
    1aa8:	21 f4       	brne	.+8      	; 0x1ab2 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1aaa:	e8 01       	movw	r28, r16
    1aac:	af 81       	ldd	r26, Y+7	; 0x07
    1aae:	b8 85       	ldd	r27, Y+8	; 0x08
    1ab0:	0e c0       	rjmp	.+28     	; 0x1ace <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1ab2:	d8 01       	movw	r26, r16
    1ab4:	13 96       	adiw	r26, 0x03	; 3
    1ab6:	12 96       	adiw	r26, 0x02	; 2
    1ab8:	2d 91       	ld	r18, X+
    1aba:	3c 91       	ld	r19, X
    1abc:	13 97       	sbiw	r26, 0x03	; 3
    1abe:	e9 01       	movw	r28, r18
    1ac0:	48 81       	ld	r20, Y
    1ac2:	59 81       	ldd	r21, Y+1	; 0x01
    1ac4:	84 17       	cp	r24, r20
    1ac6:	95 07       	cpc	r25, r21
    1ac8:	10 f0       	brcs	.+4      	; 0x1ace <vListInsert+0x3c>
    1aca:	d9 01       	movw	r26, r18
    1acc:	f4 cf       	rjmp	.-24     	; 0x1ab6 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1ace:	12 96       	adiw	r26, 0x02	; 2
    1ad0:	8d 91       	ld	r24, X+
    1ad2:	9c 91       	ld	r25, X
    1ad4:	13 97       	sbiw	r26, 0x03	; 3
    1ad6:	93 83       	std	Z+3, r25	; 0x03
    1ad8:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1ada:	ec 01       	movw	r28, r24
    1adc:	fd 83       	std	Y+5, r31	; 0x05
    1ade:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1ae0:	b5 83       	std	Z+5, r27	; 0x05
    1ae2:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1ae4:	13 96       	adiw	r26, 0x03	; 3
    1ae6:	fc 93       	st	X, r31
    1ae8:	ee 93       	st	-X, r30
    1aea:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    1aec:	11 87       	std	Z+9, r17	; 0x09
    1aee:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    1af0:	f8 01       	movw	r30, r16
    1af2:	80 81       	ld	r24, Z
    1af4:	8f 5f       	subi	r24, 0xFF	; 255
    1af6:	80 83       	st	Z, r24
}
    1af8:	df 91       	pop	r29
    1afa:	cf 91       	pop	r28
    1afc:	1f 91       	pop	r17
    1afe:	0f 91       	pop	r16
    1b00:	08 95       	ret

00001b02 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1b02:	cf 93       	push	r28
    1b04:	df 93       	push	r29
    1b06:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1b08:	a0 85       	ldd	r26, Z+8	; 0x08
    1b0a:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1b0c:	82 81       	ldd	r24, Z+2	; 0x02
    1b0e:	93 81       	ldd	r25, Z+3	; 0x03
    1b10:	24 81       	ldd	r18, Z+4	; 0x04
    1b12:	35 81       	ldd	r19, Z+5	; 0x05
    1b14:	ec 01       	movw	r28, r24
    1b16:	3d 83       	std	Y+5, r19	; 0x05
    1b18:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1b1a:	c4 81       	ldd	r28, Z+4	; 0x04
    1b1c:	d5 81       	ldd	r29, Z+5	; 0x05
    1b1e:	9b 83       	std	Y+3, r25	; 0x03
    1b20:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1b22:	11 96       	adiw	r26, 0x01	; 1
    1b24:	8d 91       	ld	r24, X+
    1b26:	9c 91       	ld	r25, X
    1b28:	12 97       	sbiw	r26, 0x02	; 2
    1b2a:	e8 17       	cp	r30, r24
    1b2c:	f9 07       	cpc	r31, r25
    1b2e:	21 f4       	brne	.+8      	; 0x1b38 <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1b30:	12 96       	adiw	r26, 0x02	; 2
    1b32:	dc 93       	st	X, r29
    1b34:	ce 93       	st	-X, r28
    1b36:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1b38:	11 86       	std	Z+9, r1	; 0x09
    1b3a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1b3c:	8c 91       	ld	r24, X
    1b3e:	81 50       	subi	r24, 0x01	; 1
    1b40:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1b42:	8c 91       	ld	r24, X
}
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	08 95       	ret

00001b4a <pxPortInitialiseStack>:
{
    portSAVE_CONTEXT();
    vTaskSwitchContext();
    portRESTORE_CONTEXT();

    __asm__ __volatile__ ( "reti" );
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	60 83       	st	Z, r22
    1b4e:	31 97       	sbiw	r30, 0x01	; 1
    1b50:	70 83       	st	Z, r23
    1b52:	31 97       	sbiw	r30, 0x01	; 1
    1b54:	10 82       	st	Z, r1
    1b56:	31 97       	sbiw	r30, 0x01	; 1
    1b58:	20 e8       	ldi	r18, 0x80	; 128
    1b5a:	20 83       	st	Z, r18
    1b5c:	31 97       	sbiw	r30, 0x01	; 1
    1b5e:	10 82       	st	Z, r1
    1b60:	77 97       	sbiw	r30, 0x17	; 23
    1b62:	40 83       	st	Z, r20
    1b64:	31 97       	sbiw	r30, 0x01	; 1
    1b66:	50 83       	st	Z, r21
    1b68:	83 97       	sbiw	r24, 0x23	; 35
    1b6a:	08 95       	ret

00001b6c <xPortStartScheduler>:
    1b6c:	a8 95       	wdr
    1b6e:	90 ec       	ldi	r25, 0xC0	; 192
    1b70:	88 e1       	ldi	r24, 0x18	; 24
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	a8 95       	wdr
    1b78:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    1b7c:	0f be       	out	0x3f, r0	; 63
    1b7e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    1b82:	a0 91 71 02 	lds	r26, 0x0271	; 0x800271 <pxCurrentTCB>
    1b86:	b0 91 72 02 	lds	r27, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1b8a:	cd 91       	ld	r28, X+
    1b8c:	cd bf       	out	0x3d, r28	; 61
    1b8e:	dd 91       	ld	r29, X+
    1b90:	de bf       	out	0x3e, r29	; 62
    1b92:	ff 91       	pop	r31
    1b94:	ef 91       	pop	r30
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	bf 91       	pop	r27
    1b9c:	af 91       	pop	r26
    1b9e:	9f 91       	pop	r25
    1ba0:	8f 91       	pop	r24
    1ba2:	7f 91       	pop	r23
    1ba4:	6f 91       	pop	r22
    1ba6:	5f 91       	pop	r21
    1ba8:	4f 91       	pop	r20
    1baa:	3f 91       	pop	r19
    1bac:	2f 91       	pop	r18
    1bae:	1f 91       	pop	r17
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	df 90       	pop	r13
    1bb8:	cf 90       	pop	r12
    1bba:	bf 90       	pop	r11
    1bbc:	af 90       	pop	r10
    1bbe:	9f 90       	pop	r9
    1bc0:	8f 90       	pop	r8
    1bc2:	7f 90       	pop	r7
    1bc4:	6f 90       	pop	r6
    1bc6:	5f 90       	pop	r5
    1bc8:	4f 90       	pop	r4
    1bca:	3f 90       	pop	r3
    1bcc:	2f 90       	pop	r2
    1bce:	1f 90       	pop	r1
    1bd0:	0f 90       	pop	r0
    1bd2:	0f be       	out	0x3f, r0	; 63
    1bd4:	0f 90       	pop	r0
    1bd6:	08 95       	ret
    1bd8:	81 e0       	ldi	r24, 0x01	; 1
    1bda:	08 95       	ret

00001bdc <vPortYield>:
    1bdc:	0f 92       	push	r0
    1bde:	0f b6       	in	r0, 0x3f	; 63
    1be0:	f8 94       	cli
    1be2:	0f 92       	push	r0
    1be4:	1f 92       	push	r1
    1be6:	11 24       	eor	r1, r1
    1be8:	2f 92       	push	r2
    1bea:	3f 92       	push	r3
    1bec:	4f 92       	push	r4
    1bee:	5f 92       	push	r5
    1bf0:	6f 92       	push	r6
    1bf2:	7f 92       	push	r7
    1bf4:	8f 92       	push	r8
    1bf6:	9f 92       	push	r9
    1bf8:	af 92       	push	r10
    1bfa:	bf 92       	push	r11
    1bfc:	cf 92       	push	r12
    1bfe:	df 92       	push	r13
    1c00:	ef 92       	push	r14
    1c02:	ff 92       	push	r15
    1c04:	0f 93       	push	r16
    1c06:	1f 93       	push	r17
    1c08:	2f 93       	push	r18
    1c0a:	3f 93       	push	r19
    1c0c:	4f 93       	push	r20
    1c0e:	5f 93       	push	r21
    1c10:	6f 93       	push	r22
    1c12:	7f 93       	push	r23
    1c14:	8f 93       	push	r24
    1c16:	9f 93       	push	r25
    1c18:	af 93       	push	r26
    1c1a:	bf 93       	push	r27
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	ef 93       	push	r30
    1c22:	ff 93       	push	r31
    1c24:	a0 91 71 02 	lds	r26, 0x0271	; 0x800271 <pxCurrentTCB>
    1c28:	b0 91 72 02 	lds	r27, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1c2c:	0d b6       	in	r0, 0x3d	; 61
    1c2e:	0d 92       	st	X+, r0
    1c30:	0e b6       	in	r0, 0x3e	; 62
    1c32:	0d 92       	st	X+, r0
    1c34:	0e 94 50 09 	call	0x12a0	; 0x12a0 <vTaskSwitchContext>
    1c38:	a0 91 71 02 	lds	r26, 0x0271	; 0x800271 <pxCurrentTCB>
    1c3c:	b0 91 72 02 	lds	r27, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1c40:	cd 91       	ld	r28, X+
    1c42:	cd bf       	out	0x3d, r28	; 61
    1c44:	dd 91       	ld	r29, X+
    1c46:	de bf       	out	0x3e, r29	; 62
    1c48:	ff 91       	pop	r31
    1c4a:	ef 91       	pop	r30
    1c4c:	df 91       	pop	r29
    1c4e:	cf 91       	pop	r28
    1c50:	bf 91       	pop	r27
    1c52:	af 91       	pop	r26
    1c54:	9f 91       	pop	r25
    1c56:	8f 91       	pop	r24
    1c58:	7f 91       	pop	r23
    1c5a:	6f 91       	pop	r22
    1c5c:	5f 91       	pop	r21
    1c5e:	4f 91       	pop	r20
    1c60:	3f 91       	pop	r19
    1c62:	2f 91       	pop	r18
    1c64:	1f 91       	pop	r17
    1c66:	0f 91       	pop	r16
    1c68:	ff 90       	pop	r15
    1c6a:	ef 90       	pop	r14
    1c6c:	df 90       	pop	r13
    1c6e:	cf 90       	pop	r12
    1c70:	bf 90       	pop	r11
    1c72:	af 90       	pop	r10
    1c74:	9f 90       	pop	r9
    1c76:	8f 90       	pop	r8
    1c78:	7f 90       	pop	r7
    1c7a:	6f 90       	pop	r6
    1c7c:	5f 90       	pop	r5
    1c7e:	4f 90       	pop	r4
    1c80:	3f 90       	pop	r3
    1c82:	2f 90       	pop	r2
    1c84:	1f 90       	pop	r1
    1c86:	0f 90       	pop	r0
    1c88:	0f be       	out	0x3f, r0	; 63
    1c8a:	0f 90       	pop	r0
    1c8c:	08 95       	ret

00001c8e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    1c8e:	0f 92       	push	r0
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	1f 92       	push	r1
    1c98:	11 24       	eor	r1, r1
    1c9a:	2f 92       	push	r2
    1c9c:	3f 92       	push	r3
    1c9e:	4f 92       	push	r4
    1ca0:	5f 92       	push	r5
    1ca2:	6f 92       	push	r6
    1ca4:	7f 92       	push	r7
    1ca6:	8f 92       	push	r8
    1ca8:	9f 92       	push	r9
    1caa:	af 92       	push	r10
    1cac:	bf 92       	push	r11
    1cae:	cf 92       	push	r12
    1cb0:	df 92       	push	r13
    1cb2:	ef 92       	push	r14
    1cb4:	ff 92       	push	r15
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	2f 93       	push	r18
    1cbc:	3f 93       	push	r19
    1cbe:	4f 93       	push	r20
    1cc0:	5f 93       	push	r21
    1cc2:	6f 93       	push	r22
    1cc4:	7f 93       	push	r23
    1cc6:	8f 93       	push	r24
    1cc8:	9f 93       	push	r25
    1cca:	af 93       	push	r26
    1ccc:	bf 93       	push	r27
    1cce:	cf 93       	push	r28
    1cd0:	df 93       	push	r29
    1cd2:	ef 93       	push	r30
    1cd4:	ff 93       	push	r31
    1cd6:	a0 91 71 02 	lds	r26, 0x0271	; 0x800271 <pxCurrentTCB>
    1cda:	b0 91 72 02 	lds	r27, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1cde:	0d b6       	in	r0, 0x3d	; 61
    1ce0:	0d 92       	st	X+, r0
    1ce2:	0e b6       	in	r0, 0x3e	; 62
    1ce4:	0d 92       	st	X+, r0
    sleep_reset();        /* reset the sleep_mode() faster than sleep_disable(); */
    1ce6:	13 be       	out	0x33, r1	; 51
    if( xTaskIncrementTick() != pdFALSE )
    1ce8:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <xTaskIncrementTick>
    1cec:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    1cee:	0e 94 50 09 	call	0x12a0	; 0x12a0 <vTaskSwitchContext>
    }
    portRESTORE_CONTEXT();
    1cf2:	a0 91 71 02 	lds	r26, 0x0271	; 0x800271 <pxCurrentTCB>
    1cf6:	b0 91 72 02 	lds	r27, 0x0272	; 0x800272 <pxCurrentTCB+0x1>
    1cfa:	cd 91       	ld	r28, X+
    1cfc:	cd bf       	out	0x3d, r28	; 61
    1cfe:	dd 91       	ld	r29, X+
    1d00:	de bf       	out	0x3e, r29	; 62
    1d02:	ff 91       	pop	r31
    1d04:	ef 91       	pop	r30
    1d06:	df 91       	pop	r29
    1d08:	cf 91       	pop	r28
    1d0a:	bf 91       	pop	r27
    1d0c:	af 91       	pop	r26
    1d0e:	9f 91       	pop	r25
    1d10:	8f 91       	pop	r24
    1d12:	7f 91       	pop	r23
    1d14:	6f 91       	pop	r22
    1d16:	5f 91       	pop	r21
    1d18:	4f 91       	pop	r20
    1d1a:	3f 91       	pop	r19
    1d1c:	2f 91       	pop	r18
    1d1e:	1f 91       	pop	r17
    1d20:	0f 91       	pop	r16
    1d22:	ff 90       	pop	r15
    1d24:	ef 90       	pop	r14
    1d26:	df 90       	pop	r13
    1d28:	cf 90       	pop	r12
    1d2a:	bf 90       	pop	r11
    1d2c:	af 90       	pop	r10
    1d2e:	9f 90       	pop	r9
    1d30:	8f 90       	pop	r8
    1d32:	7f 90       	pop	r7
    1d34:	6f 90       	pop	r6
    1d36:	5f 90       	pop	r5
    1d38:	4f 90       	pop	r4
    1d3a:	3f 90       	pop	r3
    1d3c:	2f 90       	pop	r2
    1d3e:	1f 90       	pop	r1
    1d40:	0f 90       	pop	r0
    1d42:	0f be       	out	0x3f, r0	; 63
    1d44:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    1d46:	08 95       	ret

00001d48 <__vector_6>:
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    1d48:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    1d4c:	18 95       	reti

00001d4e <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1d4e:	0f b6       	in	r0, 0x3f	; 63
    1d50:	f8 94       	cli
    1d52:	0f 92       	push	r0
    1d54:	fc 01       	movw	r30, r24
    1d56:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	91 11       	cpse	r25, r1
    1d60:	80 e0       	ldi	r24, 0x00	; 0
    1d62:	08 95       	ret

00001d64 <prvCopyDataToQueue>:
    1d64:	0f 93       	push	r16
    1d66:	1f 93       	push	r17
    1d68:	cf 93       	push	r28
    1d6a:	df 93       	push	r29
    1d6c:	ec 01       	movw	r28, r24
    1d6e:	04 2f       	mov	r16, r20
    1d70:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1d72:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d74:	41 11       	cpse	r20, r1
    1d76:	0b c0       	rjmp	.+22     	; 0x1d8e <prvCopyDataToQueue+0x2a>
    1d78:	88 81       	ld	r24, Y
    1d7a:	99 81       	ldd	r25, Y+1	; 0x01
    1d7c:	89 2b       	or	r24, r25
    1d7e:	e9 f5       	brne	.+122    	; 0x1dfa <prvCopyDataToQueue+0x96>
    1d80:	8c 81       	ldd	r24, Y+4	; 0x04
    1d82:	9d 81       	ldd	r25, Y+5	; 0x05
    1d84:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <xTaskPriorityDisinherit>
    1d88:	1d 82       	std	Y+5, r1	; 0x05
    1d8a:	1c 82       	std	Y+4, r1	; 0x04
    1d8c:	37 c0       	rjmp	.+110    	; 0x1dfc <prvCopyDataToQueue+0x98>
    1d8e:	50 e0       	ldi	r21, 0x00	; 0
    1d90:	01 11       	cpse	r16, r1
    1d92:	15 c0       	rjmp	.+42     	; 0x1dbe <prvCopyDataToQueue+0x5a>
    1d94:	8a 81       	ldd	r24, Y+2	; 0x02
    1d96:	9b 81       	ldd	r25, Y+3	; 0x03
    1d98:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <memcpy>
    1d9c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1da0:	9b 81       	ldd	r25, Y+3	; 0x03
    1da2:	82 0f       	add	r24, r18
    1da4:	91 1d       	adc	r25, r1
    1da6:	9b 83       	std	Y+3, r25	; 0x03
    1da8:	8a 83       	std	Y+2, r24	; 0x02
    1daa:	2c 81       	ldd	r18, Y+4	; 0x04
    1dac:	3d 81       	ldd	r19, Y+5	; 0x05
    1dae:	82 17       	cp	r24, r18
    1db0:	93 07       	cpc	r25, r19
    1db2:	18 f1       	brcs	.+70     	; 0x1dfa <prvCopyDataToQueue+0x96>
    1db4:	88 81       	ld	r24, Y
    1db6:	99 81       	ldd	r25, Y+1	; 0x01
    1db8:	9b 83       	std	Y+3, r25	; 0x03
    1dba:	8a 83       	std	Y+2, r24	; 0x02
    1dbc:	1e c0       	rjmp	.+60     	; 0x1dfa <prvCopyDataToQueue+0x96>
    1dbe:	8e 81       	ldd	r24, Y+6	; 0x06
    1dc0:	9f 81       	ldd	r25, Y+7	; 0x07
    1dc2:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <memcpy>
    1dc6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	91 95       	neg	r25
    1dcc:	81 95       	neg	r24
    1dce:	91 09       	sbc	r25, r1
    1dd0:	2e 81       	ldd	r18, Y+6	; 0x06
    1dd2:	3f 81       	ldd	r19, Y+7	; 0x07
    1dd4:	28 0f       	add	r18, r24
    1dd6:	39 1f       	adc	r19, r25
    1dd8:	3f 83       	std	Y+7, r19	; 0x07
    1dda:	2e 83       	std	Y+6, r18	; 0x06
    1ddc:	48 81       	ld	r20, Y
    1dde:	59 81       	ldd	r21, Y+1	; 0x01
    1de0:	24 17       	cp	r18, r20
    1de2:	35 07       	cpc	r19, r21
    1de4:	30 f4       	brcc	.+12     	; 0x1df2 <prvCopyDataToQueue+0x8e>
    1de6:	2c 81       	ldd	r18, Y+4	; 0x04
    1de8:	3d 81       	ldd	r19, Y+5	; 0x05
    1dea:	82 0f       	add	r24, r18
    1dec:	93 1f       	adc	r25, r19
    1dee:	9f 83       	std	Y+7, r25	; 0x07
    1df0:	8e 83       	std	Y+6, r24	; 0x06
    1df2:	02 30       	cpi	r16, 0x02	; 2
    1df4:	11 f4       	brne	.+4      	; 0x1dfa <prvCopyDataToQueue+0x96>
    1df6:	11 11       	cpse	r17, r1
    1df8:	11 50       	subi	r17, 0x01	; 1
    1dfa:	80 e0       	ldi	r24, 0x00	; 0
    1dfc:	1f 5f       	subi	r17, 0xFF	; 255
    1dfe:	1a 8f       	std	Y+26, r17	; 0x1a
    1e00:	df 91       	pop	r29
    1e02:	cf 91       	pop	r28
    1e04:	1f 91       	pop	r17
    1e06:	0f 91       	pop	r16
    1e08:	08 95       	ret

00001e0a <prvCopyDataFromQueue>:
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	cb 01       	movw	r24, r22
    1e0e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1e10:	44 23       	and	r20, r20
    1e12:	a1 f0       	breq	.+40     	; 0x1e3c <prvCopyDataFromQueue+0x32>
    1e14:	50 e0       	ldi	r21, 0x00	; 0
    1e16:	26 81       	ldd	r18, Z+6	; 0x06
    1e18:	37 81       	ldd	r19, Z+7	; 0x07
    1e1a:	24 0f       	add	r18, r20
    1e1c:	35 1f       	adc	r19, r21
    1e1e:	37 83       	std	Z+7, r19	; 0x07
    1e20:	26 83       	std	Z+6, r18	; 0x06
    1e22:	64 81       	ldd	r22, Z+4	; 0x04
    1e24:	75 81       	ldd	r23, Z+5	; 0x05
    1e26:	26 17       	cp	r18, r22
    1e28:	37 07       	cpc	r19, r23
    1e2a:	20 f0       	brcs	.+8      	; 0x1e34 <prvCopyDataFromQueue+0x2a>
    1e2c:	20 81       	ld	r18, Z
    1e2e:	31 81       	ldd	r19, Z+1	; 0x01
    1e30:	37 83       	std	Z+7, r19	; 0x07
    1e32:	26 83       	std	Z+6, r18	; 0x06
    1e34:	66 81       	ldd	r22, Z+6	; 0x06
    1e36:	77 81       	ldd	r23, Z+7	; 0x07
    1e38:	0c 94 7c 12 	jmp	0x24f8	; 0x24f8 <memcpy>
    1e3c:	08 95       	ret

00001e3e <prvUnlockQueue>:
    1e3e:	ef 92       	push	r14
    1e40:	ff 92       	push	r15
    1e42:	1f 93       	push	r17
    1e44:	cf 93       	push	r28
    1e46:	df 93       	push	r29
    1e48:	ec 01       	movw	r28, r24
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	f8 94       	cli
    1e4e:	0f 92       	push	r0
    1e50:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1e52:	7c 01       	movw	r14, r24
    1e54:	81 e1       	ldi	r24, 0x11	; 17
    1e56:	e8 0e       	add	r14, r24
    1e58:	f1 1c       	adc	r15, r1
    1e5a:	11 16       	cp	r1, r17
    1e5c:	5c f4       	brge	.+22     	; 0x1e74 <prvUnlockQueue+0x36>
    1e5e:	89 89       	ldd	r24, Y+17	; 0x11
    1e60:	88 23       	and	r24, r24
    1e62:	41 f0       	breq	.+16     	; 0x1e74 <prvUnlockQueue+0x36>
    1e64:	c7 01       	movw	r24, r14
    1e66:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskRemoveFromEventList>
    1e6a:	81 11       	cpse	r24, r1
    1e6c:	0e 94 55 0a 	call	0x14aa	; 0x14aa <vTaskMissedYield>
    1e70:	11 50       	subi	r17, 0x01	; 1
    1e72:	f3 cf       	rjmp	.-26     	; 0x1e5a <prvUnlockQueue+0x1c>
    1e74:	8f ef       	ldi	r24, 0xFF	; 255
    1e76:	8e 8f       	std	Y+30, r24	; 0x1e
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	0f b6       	in	r0, 0x3f	; 63
    1e7e:	f8 94       	cli
    1e80:	0f 92       	push	r0
    1e82:	1d 8d       	ldd	r17, Y+29	; 0x1d
    1e84:	7e 01       	movw	r14, r28
    1e86:	88 e0       	ldi	r24, 0x08	; 8
    1e88:	e8 0e       	add	r14, r24
    1e8a:	f1 1c       	adc	r15, r1
    1e8c:	11 16       	cp	r1, r17
    1e8e:	5c f4       	brge	.+22     	; 0x1ea6 <prvUnlockQueue+0x68>
    1e90:	88 85       	ldd	r24, Y+8	; 0x08
    1e92:	88 23       	and	r24, r24
    1e94:	41 f0       	breq	.+16     	; 0x1ea6 <prvUnlockQueue+0x68>
    1e96:	c7 01       	movw	r24, r14
    1e98:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskRemoveFromEventList>
    1e9c:	81 11       	cpse	r24, r1
    1e9e:	0e 94 55 0a 	call	0x14aa	; 0x14aa <vTaskMissedYield>
    1ea2:	11 50       	subi	r17, 0x01	; 1
    1ea4:	f3 cf       	rjmp	.-26     	; 0x1e8c <prvUnlockQueue+0x4e>
    1ea6:	8f ef       	ldi	r24, 0xFF	; 255
    1ea8:	8d 8f       	std	Y+29, r24	; 0x1d
    1eaa:	0f 90       	pop	r0
    1eac:	0f be       	out	0x3f, r0	; 63
    1eae:	df 91       	pop	r29
    1eb0:	cf 91       	pop	r28
    1eb2:	1f 91       	pop	r17
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	08 95       	ret

00001eba <xQueueGenericReset>:
    1eba:	cf 93       	push	r28
    1ebc:	df 93       	push	r29
    1ebe:	ec 01       	movw	r28, r24
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	0f 92       	push	r0
    1ec6:	48 81       	ld	r20, Y
    1ec8:	59 81       	ldd	r21, Y+1	; 0x01
    1eca:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ecc:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1ece:	9a 01       	movw	r18, r20
    1ed0:	87 9f       	mul	r24, r23
    1ed2:	20 0d       	add	r18, r0
    1ed4:	31 1d       	adc	r19, r1
    1ed6:	11 24       	eor	r1, r1
    1ed8:	3d 83       	std	Y+5, r19	; 0x05
    1eda:	2c 83       	std	Y+4, r18	; 0x04
    1edc:	1a 8e       	std	Y+26, r1	; 0x1a
    1ede:	5b 83       	std	Y+3, r21	; 0x03
    1ee0:	4a 83       	std	Y+2, r20	; 0x02
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	01 97       	sbiw	r24, 0x01	; 1
    1ee6:	78 9f       	mul	r23, r24
    1ee8:	90 01       	movw	r18, r0
    1eea:	79 9f       	mul	r23, r25
    1eec:	30 0d       	add	r19, r0
    1eee:	11 24       	eor	r1, r1
    1ef0:	ca 01       	movw	r24, r20
    1ef2:	82 0f       	add	r24, r18
    1ef4:	93 1f       	adc	r25, r19
    1ef6:	9f 83       	std	Y+7, r25	; 0x07
    1ef8:	8e 83       	std	Y+6, r24	; 0x06
    1efa:	8f ef       	ldi	r24, 0xFF	; 255
    1efc:	8d 8f       	std	Y+29, r24	; 0x1d
    1efe:	8e 8f       	std	Y+30, r24	; 0x1e
    1f00:	61 11       	cpse	r22, r1
    1f02:	0c c0       	rjmp	.+24     	; 0x1f1c <xQueueGenericReset+0x62>
    1f04:	88 85       	ldd	r24, Y+8	; 0x08
    1f06:	88 23       	and	r24, r24
    1f08:	89 f0       	breq	.+34     	; 0x1f2c <xQueueGenericReset+0x72>
    1f0a:	ce 01       	movw	r24, r28
    1f0c:	08 96       	adiw	r24, 0x08	; 8
    1f0e:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskRemoveFromEventList>
    1f12:	88 23       	and	r24, r24
    1f14:	59 f0       	breq	.+22     	; 0x1f2c <xQueueGenericReset+0x72>
    1f16:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    1f1a:	08 c0       	rjmp	.+16     	; 0x1f2c <xQueueGenericReset+0x72>
    1f1c:	ce 01       	movw	r24, r28
    1f1e:	08 96       	adiw	r24, 0x08	; 8
    1f20:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
    1f24:	ce 01       	movw	r24, r28
    1f26:	41 96       	adiw	r24, 0x11	; 17
    1f28:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vListInitialise>
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	81 e0       	ldi	r24, 0x01	; 1
    1f32:	df 91       	pop	r29
    1f34:	cf 91       	pop	r28
    1f36:	08 95       	ret

00001f38 <xQueueGenericCreate>:
    1f38:	0f 93       	push	r16
    1f3a:	1f 93       	push	r17
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	08 2f       	mov	r16, r24
    1f42:	16 2f       	mov	r17, r22
    1f44:	86 9f       	mul	r24, r22
    1f46:	c0 01       	movw	r24, r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	4f 96       	adiw	r24, 0x1f	; 31
    1f4c:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <pvPortMalloc>
    1f50:	ec 01       	movw	r28, r24
    1f52:	00 97       	sbiw	r24, 0x00	; 0
    1f54:	71 f0       	breq	.+28     	; 0x1f72 <xQueueGenericCreate+0x3a>
    1f56:	11 11       	cpse	r17, r1
    1f58:	03 c0       	rjmp	.+6      	; 0x1f60 <xQueueGenericCreate+0x28>
    1f5a:	99 83       	std	Y+1, r25	; 0x01
    1f5c:	88 83       	st	Y, r24
    1f5e:	03 c0       	rjmp	.+6      	; 0x1f66 <xQueueGenericCreate+0x2e>
    1f60:	4f 96       	adiw	r24, 0x1f	; 31
    1f62:	99 83       	std	Y+1, r25	; 0x01
    1f64:	88 83       	st	Y, r24
    1f66:	0b 8f       	std	Y+27, r16	; 0x1b
    1f68:	1c 8f       	std	Y+28, r17	; 0x1c
    1f6a:	61 e0       	ldi	r22, 0x01	; 1
    1f6c:	ce 01       	movw	r24, r28
    1f6e:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <xQueueGenericReset>
    1f72:	ce 01       	movw	r24, r28
    1f74:	df 91       	pop	r29
    1f76:	cf 91       	pop	r28
    1f78:	1f 91       	pop	r17
    1f7a:	0f 91       	pop	r16
    1f7c:	08 95       	ret

00001f7e <xQueueGenericSend>:
    1f7e:	af 92       	push	r10
    1f80:	bf 92       	push	r11
    1f82:	cf 92       	push	r12
    1f84:	df 92       	push	r13
    1f86:	ff 92       	push	r15
    1f88:	0f 93       	push	r16
    1f8a:	1f 93       	push	r17
    1f8c:	cf 93       	push	r28
    1f8e:	df 93       	push	r29
    1f90:	00 d0       	rcall	.+0      	; 0x1f92 <xQueueGenericSend+0x14>
    1f92:	00 d0       	rcall	.+0      	; 0x1f94 <xQueueGenericSend+0x16>
    1f94:	1f 92       	push	r1
    1f96:	cd b7       	in	r28, 0x3d	; 61
    1f98:	de b7       	in	r29, 0x3e	; 62
    1f9a:	8c 01       	movw	r16, r24
    1f9c:	6b 01       	movw	r12, r22
    1f9e:	5d 83       	std	Y+5, r21	; 0x05
    1fa0:	4c 83       	std	Y+4, r20	; 0x04
    1fa2:	f2 2e       	mov	r15, r18
    1fa4:	80 e0       	ldi	r24, 0x00	; 0
    1fa6:	58 01       	movw	r10, r16
    1fa8:	98 e0       	ldi	r25, 0x08	; 8
    1faa:	a9 0e       	add	r10, r25
    1fac:	b1 1c       	adc	r11, r1
    1fae:	0f b6       	in	r0, 0x3f	; 63
    1fb0:	f8 94       	cli
    1fb2:	0f 92       	push	r0
    1fb4:	f8 01       	movw	r30, r16
    1fb6:	22 8d       	ldd	r18, Z+26	; 0x1a
    1fb8:	93 8d       	ldd	r25, Z+27	; 0x1b
    1fba:	29 17       	cp	r18, r25
    1fbc:	18 f0       	brcs	.+6      	; 0x1fc4 <xQueueGenericSend+0x46>
    1fbe:	f2 e0       	ldi	r31, 0x02	; 2
    1fc0:	ff 12       	cpse	r15, r31
    1fc2:	14 c0       	rjmp	.+40     	; 0x1fec <xQueueGenericSend+0x6e>
    1fc4:	4f 2d       	mov	r20, r15
    1fc6:	b6 01       	movw	r22, r12
    1fc8:	c8 01       	movw	r24, r16
    1fca:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <prvCopyDataToQueue>
    1fce:	f8 01       	movw	r30, r16
    1fd0:	91 89       	ldd	r25, Z+17	; 0x11
    1fd2:	99 23       	and	r25, r25
    1fd4:	21 f0       	breq	.+8      	; 0x1fde <xQueueGenericSend+0x60>
    1fd6:	c8 01       	movw	r24, r16
    1fd8:	41 96       	adiw	r24, 0x11	; 17
    1fda:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskRemoveFromEventList>
    1fde:	81 11       	cpse	r24, r1
    1fe0:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    1fe4:	0f 90       	pop	r0
    1fe6:	0f be       	out	0x3f, r0	; 63
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	50 c0       	rjmp	.+160    	; 0x208c <xQueueGenericSend+0x10e>
    1fec:	2c 81       	ldd	r18, Y+4	; 0x04
    1fee:	3d 81       	ldd	r19, Y+5	; 0x05
    1ff0:	23 2b       	or	r18, r19
    1ff2:	19 f4       	brne	.+6      	; 0x1ffa <xQueueGenericSend+0x7c>
    1ff4:	0f 90       	pop	r0
    1ff6:	0f be       	out	0x3f, r0	; 63
    1ff8:	48 c0       	rjmp	.+144    	; 0x208a <xQueueGenericSend+0x10c>
    1ffa:	81 11       	cpse	r24, r1
    1ffc:	04 c0       	rjmp	.+8      	; 0x2006 <xQueueGenericSend+0x88>
    1ffe:	ce 01       	movw	r24, r28
    2000:	01 96       	adiw	r24, 0x01	; 1
    2002:	0e 94 17 0a 	call	0x142e	; 0x142e <vTaskInternalSetTimeOutState>
    2006:	0f 90       	pop	r0
    2008:	0f be       	out	0x3f, r0	; 63
    200a:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vTaskSuspendAll>
    200e:	0f b6       	in	r0, 0x3f	; 63
    2010:	f8 94       	cli
    2012:	0f 92       	push	r0
    2014:	f8 01       	movw	r30, r16
    2016:	85 8d       	ldd	r24, Z+29	; 0x1d
    2018:	8f 3f       	cpi	r24, 0xFF	; 255
    201a:	09 f4       	brne	.+2      	; 0x201e <xQueueGenericSend+0xa0>
    201c:	15 8e       	std	Z+29, r1	; 0x1d
    201e:	f8 01       	movw	r30, r16
    2020:	86 8d       	ldd	r24, Z+30	; 0x1e
    2022:	8f 3f       	cpi	r24, 0xFF	; 255
    2024:	09 f4       	brne	.+2      	; 0x2028 <xQueueGenericSend+0xaa>
    2026:	16 8e       	std	Z+30, r1	; 0x1e
    2028:	0f 90       	pop	r0
    202a:	0f be       	out	0x3f, r0	; 63
    202c:	be 01       	movw	r22, r28
    202e:	6c 5f       	subi	r22, 0xFC	; 252
    2030:	7f 4f       	sbci	r23, 0xFF	; 255
    2032:	ce 01       	movw	r24, r28
    2034:	01 96       	adiw	r24, 0x01	; 1
    2036:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskCheckForTimeOut>
    203a:	81 11       	cpse	r24, r1
    203c:	21 c0       	rjmp	.+66     	; 0x2080 <xQueueGenericSend+0x102>
    203e:	0f b6       	in	r0, 0x3f	; 63
    2040:	f8 94       	cli
    2042:	0f 92       	push	r0
    2044:	f8 01       	movw	r30, r16
    2046:	92 8d       	ldd	r25, Z+26	; 0x1a
    2048:	83 8d       	ldd	r24, Z+27	; 0x1b
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	98 13       	cpse	r25, r24
    2050:	11 c0       	rjmp	.+34     	; 0x2074 <xQueueGenericSend+0xf6>
    2052:	6c 81       	ldd	r22, Y+4	; 0x04
    2054:	7d 81       	ldd	r23, Y+5	; 0x05
    2056:	c5 01       	movw	r24, r10
    2058:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskPlaceOnEventList>
    205c:	c8 01       	movw	r24, r16
    205e:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <prvUnlockQueue>
    2062:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    2066:	88 23       	and	r24, r24
    2068:	11 f0       	breq	.+4      	; 0x206e <xQueueGenericSend+0xf0>
    206a:	81 e0       	ldi	r24, 0x01	; 1
    206c:	a0 cf       	rjmp	.-192    	; 0x1fae <xQueueGenericSend+0x30>
    206e:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    2072:	fb cf       	rjmp	.-10     	; 0x206a <xQueueGenericSend+0xec>
    2074:	c8 01       	movw	r24, r16
    2076:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <prvUnlockQueue>
    207a:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    207e:	f5 cf       	rjmp	.-22     	; 0x206a <xQueueGenericSend+0xec>
    2080:	c8 01       	movw	r24, r16
    2082:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <prvUnlockQueue>
    2086:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    208a:	80 e0       	ldi	r24, 0x00	; 0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	0f 90       	pop	r0
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	df 91       	pop	r29
    2098:	cf 91       	pop	r28
    209a:	1f 91       	pop	r17
    209c:	0f 91       	pop	r16
    209e:	ff 90       	pop	r15
    20a0:	df 90       	pop	r13
    20a2:	cf 90       	pop	r12
    20a4:	bf 90       	pop	r11
    20a6:	af 90       	pop	r10
    20a8:	08 95       	ret

000020aa <xQueueGenericSendFromISR>:
    20aa:	ef 92       	push	r14
    20ac:	ff 92       	push	r15
    20ae:	1f 93       	push	r17
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
    20b4:	ec 01       	movw	r28, r24
    20b6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    20b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20ba:	98 17       	cp	r25, r24
    20bc:	10 f0       	brcs	.+4      	; 0x20c2 <xQueueGenericSendFromISR+0x18>
    20be:	22 30       	cpi	r18, 0x02	; 2
    20c0:	e9 f4       	brne	.+58     	; 0x20fc <xQueueGenericSendFromISR+0x52>
    20c2:	7a 01       	movw	r14, r20
    20c4:	1e 8d       	ldd	r17, Y+30	; 0x1e
    20c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20c8:	42 2f       	mov	r20, r18
    20ca:	ce 01       	movw	r24, r28
    20cc:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <prvCopyDataToQueue>
    20d0:	1f 3f       	cpi	r17, 0xFF	; 255
    20d2:	81 f4       	brne	.+32     	; 0x20f4 <xQueueGenericSendFromISR+0x4a>
    20d4:	89 89       	ldd	r24, Y+17	; 0x11
    20d6:	88 23       	and	r24, r24
    20d8:	79 f0       	breq	.+30     	; 0x20f8 <xQueueGenericSendFromISR+0x4e>
    20da:	ce 01       	movw	r24, r28
    20dc:	41 96       	adiw	r24, 0x11	; 17
    20de:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskRemoveFromEventList>
    20e2:	88 23       	and	r24, r24
    20e4:	49 f0       	breq	.+18     	; 0x20f8 <xQueueGenericSendFromISR+0x4e>
    20e6:	e1 14       	cp	r14, r1
    20e8:	f1 04       	cpc	r15, r1
    20ea:	31 f0       	breq	.+12     	; 0x20f8 <xQueueGenericSendFromISR+0x4e>
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	f7 01       	movw	r30, r14
    20f0:	80 83       	st	Z, r24
    20f2:	05 c0       	rjmp	.+10     	; 0x20fe <xQueueGenericSendFromISR+0x54>
    20f4:	1f 5f       	subi	r17, 0xFF	; 255
    20f6:	1e 8f       	std	Y+30, r17	; 0x1e
    20f8:	81 e0       	ldi	r24, 0x01	; 1
    20fa:	01 c0       	rjmp	.+2      	; 0x20fe <xQueueGenericSendFromISR+0x54>
    20fc:	80 e0       	ldi	r24, 0x00	; 0
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	1f 91       	pop	r17
    2104:	ff 90       	pop	r15
    2106:	ef 90       	pop	r14
    2108:	08 95       	ret

0000210a <xQueueReceive>:
    210a:	af 92       	push	r10
    210c:	bf 92       	push	r11
    210e:	cf 92       	push	r12
    2110:	df 92       	push	r13
    2112:	ff 92       	push	r15
    2114:	0f 93       	push	r16
    2116:	1f 93       	push	r17
    2118:	cf 93       	push	r28
    211a:	df 93       	push	r29
    211c:	00 d0       	rcall	.+0      	; 0x211e <xQueueReceive+0x14>
    211e:	00 d0       	rcall	.+0      	; 0x2120 <xQueueReceive+0x16>
    2120:	1f 92       	push	r1
    2122:	cd b7       	in	r28, 0x3d	; 61
    2124:	de b7       	in	r29, 0x3e	; 62
    2126:	8c 01       	movw	r16, r24
    2128:	6b 01       	movw	r12, r22
    212a:	5d 83       	std	Y+5, r21	; 0x05
    212c:	4c 83       	std	Y+4, r20	; 0x04
    212e:	80 e0       	ldi	r24, 0x00	; 0
    2130:	58 01       	movw	r10, r16
    2132:	91 e1       	ldi	r25, 0x11	; 17
    2134:	a9 0e       	add	r10, r25
    2136:	b1 1c       	adc	r11, r1
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	0f 92       	push	r0
    213e:	f8 01       	movw	r30, r16
    2140:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2142:	ff 20       	and	r15, r15
    2144:	a9 f0       	breq	.+42     	; 0x2170 <xQueueReceive+0x66>
    2146:	b6 01       	movw	r22, r12
    2148:	c8 01       	movw	r24, r16
    214a:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <prvCopyDataFromQueue>
    214e:	fa 94       	dec	r15
    2150:	f8 01       	movw	r30, r16
    2152:	f2 8e       	std	Z+26, r15	; 0x1a
    2154:	80 85       	ldd	r24, Z+8	; 0x08
    2156:	88 23       	and	r24, r24
    2158:	39 f0       	breq	.+14     	; 0x2168 <xQueueReceive+0x5e>
    215a:	c8 01       	movw	r24, r16
    215c:	08 96       	adiw	r24, 0x08	; 8
    215e:	0e 94 d7 09 	call	0x13ae	; 0x13ae <xTaskRemoveFromEventList>
    2162:	81 11       	cpse	r24, r1
    2164:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    2168:	0f 90       	pop	r0
    216a:	0f be       	out	0x3f, r0	; 63
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	50 c0       	rjmp	.+160    	; 0x2210 <xQueueReceive+0x106>
    2170:	2c 81       	ldd	r18, Y+4	; 0x04
    2172:	3d 81       	ldd	r19, Y+5	; 0x05
    2174:	23 2b       	or	r18, r19
    2176:	19 f4       	brne	.+6      	; 0x217e <xQueueReceive+0x74>
    2178:	0f 90       	pop	r0
    217a:	0f be       	out	0x3f, r0	; 63
    217c:	48 c0       	rjmp	.+144    	; 0x220e <xQueueReceive+0x104>
    217e:	81 11       	cpse	r24, r1
    2180:	04 c0       	rjmp	.+8      	; 0x218a <xQueueReceive+0x80>
    2182:	ce 01       	movw	r24, r28
    2184:	01 96       	adiw	r24, 0x01	; 1
    2186:	0e 94 17 0a 	call	0x142e	; 0x142e <vTaskInternalSetTimeOutState>
    218a:	0f 90       	pop	r0
    218c:	0f be       	out	0x3f, r0	; 63
    218e:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vTaskSuspendAll>
    2192:	0f b6       	in	r0, 0x3f	; 63
    2194:	f8 94       	cli
    2196:	0f 92       	push	r0
    2198:	f8 01       	movw	r30, r16
    219a:	85 8d       	ldd	r24, Z+29	; 0x1d
    219c:	8f 3f       	cpi	r24, 0xFF	; 255
    219e:	09 f4       	brne	.+2      	; 0x21a2 <xQueueReceive+0x98>
    21a0:	15 8e       	std	Z+29, r1	; 0x1d
    21a2:	f8 01       	movw	r30, r16
    21a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    21a6:	8f 3f       	cpi	r24, 0xFF	; 255
    21a8:	09 f4       	brne	.+2      	; 0x21ac <xQueueReceive+0xa2>
    21aa:	16 8e       	std	Z+30, r1	; 0x1e
    21ac:	0f 90       	pop	r0
    21ae:	0f be       	out	0x3f, r0	; 63
    21b0:	be 01       	movw	r22, r28
    21b2:	6c 5f       	subi	r22, 0xFC	; 252
    21b4:	7f 4f       	sbci	r23, 0xFF	; 255
    21b6:	ce 01       	movw	r24, r28
    21b8:	01 96       	adiw	r24, 0x01	; 1
    21ba:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskCheckForTimeOut>
    21be:	81 11       	cpse	r24, r1
    21c0:	1c c0       	rjmp	.+56     	; 0x21fa <xQueueReceive+0xf0>
    21c2:	c8 01       	movw	r24, r16
    21c4:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <prvIsQueueEmpty>
    21c8:	88 23       	and	r24, r24
    21ca:	89 f0       	breq	.+34     	; 0x21ee <xQueueReceive+0xe4>
    21cc:	6c 81       	ldd	r22, Y+4	; 0x04
    21ce:	7d 81       	ldd	r23, Y+5	; 0x05
    21d0:	c5 01       	movw	r24, r10
    21d2:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskPlaceOnEventList>
    21d6:	c8 01       	movw	r24, r16
    21d8:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <prvUnlockQueue>
    21dc:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    21e0:	88 23       	and	r24, r24
    21e2:	11 f0       	breq	.+4      	; 0x21e8 <xQueueReceive+0xde>
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	a8 cf       	rjmp	.-176    	; 0x2138 <xQueueReceive+0x2e>
    21e8:	0e 94 ee 0d 	call	0x1bdc	; 0x1bdc <vPortYield>
    21ec:	fb cf       	rjmp	.-10     	; 0x21e4 <xQueueReceive+0xda>
    21ee:	c8 01       	movw	r24, r16
    21f0:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <prvUnlockQueue>
    21f4:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    21f8:	f5 cf       	rjmp	.-22     	; 0x21e4 <xQueueReceive+0xda>
    21fa:	c8 01       	movw	r24, r16
    21fc:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <prvUnlockQueue>
    2200:	0e 94 a5 08 	call	0x114a	; 0x114a <xTaskResumeAll>
    2204:	c8 01       	movw	r24, r16
    2206:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <prvIsQueueEmpty>
    220a:	88 23       	and	r24, r24
    220c:	59 f3       	breq	.-42     	; 0x21e4 <xQueueReceive+0xda>
    220e:	80 e0       	ldi	r24, 0x00	; 0
    2210:	0f 90       	pop	r0
    2212:	0f 90       	pop	r0
    2214:	0f 90       	pop	r0
    2216:	0f 90       	pop	r0
    2218:	0f 90       	pop	r0
    221a:	df 91       	pop	r29
    221c:	cf 91       	pop	r28
    221e:	1f 91       	pop	r17
    2220:	0f 91       	pop	r16
    2222:	ff 90       	pop	r15
    2224:	df 90       	pop	r13
    2226:	cf 90       	pop	r12
    2228:	bf 90       	pop	r11
    222a:	af 90       	pop	r10
    222c:	08 95       	ret

0000222e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    222e:	cf 93       	push	r28
    2230:	df 93       	push	r29
    2232:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	0f 92       	push	r0
    223a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    223c:	8f 3f       	cpi	r24, 0xFF	; 255
    223e:	09 f4       	brne	.+2      	; 0x2242 <vQueueWaitForMessageRestricted+0x14>
    2240:	1d 8e       	std	Y+29, r1	; 0x1d
    2242:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2244:	8f 3f       	cpi	r24, 0xFF	; 255
    2246:	09 f4       	brne	.+2      	; 0x224a <vQueueWaitForMessageRestricted+0x1c>
    2248:	1e 8e       	std	Y+30, r1	; 0x1e
    224a:	0f 90       	pop	r0
    224c:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    224e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2250:	81 11       	cpse	r24, r1
    2252:	04 c0       	rjmp	.+8      	; 0x225c <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2254:	ce 01       	movw	r24, r28
    2256:	41 96       	adiw	r24, 0x11	; 17
    2258:	0e 94 bf 09 	call	0x137e	; 0x137e <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    225c:	ce 01       	movw	r24, r28
    }
    225e:	df 91       	pop	r29
    2260:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    2262:	0c 94 1f 0f 	jmp	0x1e3e	; 0x1e3e <prvUnlockQueue>

00002266 <__udivmodsi4>:
    2266:	a1 e2       	ldi	r26, 0x21	; 33
    2268:	1a 2e       	mov	r1, r26
    226a:	aa 1b       	sub	r26, r26
    226c:	bb 1b       	sub	r27, r27
    226e:	fd 01       	movw	r30, r26
    2270:	0d c0       	rjmp	.+26     	; 0x228c <__udivmodsi4_ep>

00002272 <__udivmodsi4_loop>:
    2272:	aa 1f       	adc	r26, r26
    2274:	bb 1f       	adc	r27, r27
    2276:	ee 1f       	adc	r30, r30
    2278:	ff 1f       	adc	r31, r31
    227a:	a2 17       	cp	r26, r18
    227c:	b3 07       	cpc	r27, r19
    227e:	e4 07       	cpc	r30, r20
    2280:	f5 07       	cpc	r31, r21
    2282:	20 f0       	brcs	.+8      	; 0x228c <__udivmodsi4_ep>
    2284:	a2 1b       	sub	r26, r18
    2286:	b3 0b       	sbc	r27, r19
    2288:	e4 0b       	sbc	r30, r20
    228a:	f5 0b       	sbc	r31, r21

0000228c <__udivmodsi4_ep>:
    228c:	66 1f       	adc	r22, r22
    228e:	77 1f       	adc	r23, r23
    2290:	88 1f       	adc	r24, r24
    2292:	99 1f       	adc	r25, r25
    2294:	1a 94       	dec	r1
    2296:	69 f7       	brne	.-38     	; 0x2272 <__udivmodsi4_loop>
    2298:	60 95       	com	r22
    229a:	70 95       	com	r23
    229c:	80 95       	com	r24
    229e:	90 95       	com	r25
    22a0:	9b 01       	movw	r18, r22
    22a2:	ac 01       	movw	r20, r24
    22a4:	bd 01       	movw	r22, r26
    22a6:	cf 01       	movw	r24, r30
    22a8:	08 95       	ret

000022aa <__tablejump2__>:
    22aa:	ee 0f       	add	r30, r30
    22ac:	ff 1f       	adc	r31, r31
    22ae:	05 90       	lpm	r0, Z+
    22b0:	f4 91       	lpm	r31, Z
    22b2:	e0 2d       	mov	r30, r0
    22b4:	09 94       	ijmp

000022b6 <malloc>:
    22b6:	0f 93       	push	r16
    22b8:	1f 93       	push	r17
    22ba:	cf 93       	push	r28
    22bc:	df 93       	push	r29
    22be:	82 30       	cpi	r24, 0x02	; 2
    22c0:	91 05       	cpc	r25, r1
    22c2:	10 f4       	brcc	.+4      	; 0x22c8 <malloc+0x12>
    22c4:	82 e0       	ldi	r24, 0x02	; 2
    22c6:	90 e0       	ldi	r25, 0x00	; 0
    22c8:	e0 91 91 02 	lds	r30, 0x0291	; 0x800291 <__flp>
    22cc:	f0 91 92 02 	lds	r31, 0x0292	; 0x800292 <__flp+0x1>
    22d0:	20 e0       	ldi	r18, 0x00	; 0
    22d2:	30 e0       	ldi	r19, 0x00	; 0
    22d4:	a0 e0       	ldi	r26, 0x00	; 0
    22d6:	b0 e0       	ldi	r27, 0x00	; 0
    22d8:	30 97       	sbiw	r30, 0x00	; 0
    22da:	19 f1       	breq	.+70     	; 0x2322 <malloc+0x6c>
    22dc:	40 81       	ld	r20, Z
    22de:	51 81       	ldd	r21, Z+1	; 0x01
    22e0:	02 81       	ldd	r16, Z+2	; 0x02
    22e2:	13 81       	ldd	r17, Z+3	; 0x03
    22e4:	48 17       	cp	r20, r24
    22e6:	59 07       	cpc	r21, r25
    22e8:	c8 f0       	brcs	.+50     	; 0x231c <malloc+0x66>
    22ea:	84 17       	cp	r24, r20
    22ec:	95 07       	cpc	r25, r21
    22ee:	69 f4       	brne	.+26     	; 0x230a <malloc+0x54>
    22f0:	10 97       	sbiw	r26, 0x00	; 0
    22f2:	31 f0       	breq	.+12     	; 0x2300 <malloc+0x4a>
    22f4:	12 96       	adiw	r26, 0x02	; 2
    22f6:	0c 93       	st	X, r16
    22f8:	12 97       	sbiw	r26, 0x02	; 2
    22fa:	13 96       	adiw	r26, 0x03	; 3
    22fc:	1c 93       	st	X, r17
    22fe:	27 c0       	rjmp	.+78     	; 0x234e <malloc+0x98>
    2300:	00 93 91 02 	sts	0x0291, r16	; 0x800291 <__flp>
    2304:	10 93 92 02 	sts	0x0292, r17	; 0x800292 <__flp+0x1>
    2308:	22 c0       	rjmp	.+68     	; 0x234e <malloc+0x98>
    230a:	21 15       	cp	r18, r1
    230c:	31 05       	cpc	r19, r1
    230e:	19 f0       	breq	.+6      	; 0x2316 <malloc+0x60>
    2310:	42 17       	cp	r20, r18
    2312:	53 07       	cpc	r21, r19
    2314:	18 f4       	brcc	.+6      	; 0x231c <malloc+0x66>
    2316:	9a 01       	movw	r18, r20
    2318:	bd 01       	movw	r22, r26
    231a:	ef 01       	movw	r28, r30
    231c:	df 01       	movw	r26, r30
    231e:	f8 01       	movw	r30, r16
    2320:	db cf       	rjmp	.-74     	; 0x22d8 <malloc+0x22>
    2322:	21 15       	cp	r18, r1
    2324:	31 05       	cpc	r19, r1
    2326:	f9 f0       	breq	.+62     	; 0x2366 <malloc+0xb0>
    2328:	28 1b       	sub	r18, r24
    232a:	39 0b       	sbc	r19, r25
    232c:	24 30       	cpi	r18, 0x04	; 4
    232e:	31 05       	cpc	r19, r1
    2330:	80 f4       	brcc	.+32     	; 0x2352 <malloc+0x9c>
    2332:	8a 81       	ldd	r24, Y+2	; 0x02
    2334:	9b 81       	ldd	r25, Y+3	; 0x03
    2336:	61 15       	cp	r22, r1
    2338:	71 05       	cpc	r23, r1
    233a:	21 f0       	breq	.+8      	; 0x2344 <malloc+0x8e>
    233c:	fb 01       	movw	r30, r22
    233e:	93 83       	std	Z+3, r25	; 0x03
    2340:	82 83       	std	Z+2, r24	; 0x02
    2342:	04 c0       	rjmp	.+8      	; 0x234c <malloc+0x96>
    2344:	90 93 92 02 	sts	0x0292, r25	; 0x800292 <__flp+0x1>
    2348:	80 93 91 02 	sts	0x0291, r24	; 0x800291 <__flp>
    234c:	fe 01       	movw	r30, r28
    234e:	32 96       	adiw	r30, 0x02	; 2
    2350:	44 c0       	rjmp	.+136    	; 0x23da <malloc+0x124>
    2352:	fe 01       	movw	r30, r28
    2354:	e2 0f       	add	r30, r18
    2356:	f3 1f       	adc	r31, r19
    2358:	81 93       	st	Z+, r24
    235a:	91 93       	st	Z+, r25
    235c:	22 50       	subi	r18, 0x02	; 2
    235e:	31 09       	sbc	r19, r1
    2360:	39 83       	std	Y+1, r19	; 0x01
    2362:	28 83       	st	Y, r18
    2364:	3a c0       	rjmp	.+116    	; 0x23da <malloc+0x124>
    2366:	20 91 8f 02 	lds	r18, 0x028F	; 0x80028f <__brkval>
    236a:	30 91 90 02 	lds	r19, 0x0290	; 0x800290 <__brkval+0x1>
    236e:	23 2b       	or	r18, r19
    2370:	41 f4       	brne	.+16     	; 0x2382 <malloc+0xcc>
    2372:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    2376:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    237a:	30 93 90 02 	sts	0x0290, r19	; 0x800290 <__brkval+0x1>
    237e:	20 93 8f 02 	sts	0x028F, r18	; 0x80028f <__brkval>
    2382:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    2386:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    238a:	21 15       	cp	r18, r1
    238c:	31 05       	cpc	r19, r1
    238e:	41 f4       	brne	.+16     	; 0x23a0 <malloc+0xea>
    2390:	2d b7       	in	r18, 0x3d	; 61
    2392:	3e b7       	in	r19, 0x3e	; 62
    2394:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    2398:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    239c:	24 1b       	sub	r18, r20
    239e:	35 0b       	sbc	r19, r21
    23a0:	e0 91 8f 02 	lds	r30, 0x028F	; 0x80028f <__brkval>
    23a4:	f0 91 90 02 	lds	r31, 0x0290	; 0x800290 <__brkval+0x1>
    23a8:	e2 17       	cp	r30, r18
    23aa:	f3 07       	cpc	r31, r19
    23ac:	a0 f4       	brcc	.+40     	; 0x23d6 <malloc+0x120>
    23ae:	2e 1b       	sub	r18, r30
    23b0:	3f 0b       	sbc	r19, r31
    23b2:	28 17       	cp	r18, r24
    23b4:	39 07       	cpc	r19, r25
    23b6:	78 f0       	brcs	.+30     	; 0x23d6 <malloc+0x120>
    23b8:	ac 01       	movw	r20, r24
    23ba:	4e 5f       	subi	r20, 0xFE	; 254
    23bc:	5f 4f       	sbci	r21, 0xFF	; 255
    23be:	24 17       	cp	r18, r20
    23c0:	35 07       	cpc	r19, r21
    23c2:	48 f0       	brcs	.+18     	; 0x23d6 <malloc+0x120>
    23c4:	4e 0f       	add	r20, r30
    23c6:	5f 1f       	adc	r21, r31
    23c8:	50 93 90 02 	sts	0x0290, r21	; 0x800290 <__brkval+0x1>
    23cc:	40 93 8f 02 	sts	0x028F, r20	; 0x80028f <__brkval>
    23d0:	81 93       	st	Z+, r24
    23d2:	91 93       	st	Z+, r25
    23d4:	02 c0       	rjmp	.+4      	; 0x23da <malloc+0x124>
    23d6:	e0 e0       	ldi	r30, 0x00	; 0
    23d8:	f0 e0       	ldi	r31, 0x00	; 0
    23da:	cf 01       	movw	r24, r30
    23dc:	df 91       	pop	r29
    23de:	cf 91       	pop	r28
    23e0:	1f 91       	pop	r17
    23e2:	0f 91       	pop	r16
    23e4:	08 95       	ret

000023e6 <free>:
    23e6:	cf 93       	push	r28
    23e8:	df 93       	push	r29
    23ea:	00 97       	sbiw	r24, 0x00	; 0
    23ec:	09 f4       	brne	.+2      	; 0x23f0 <free+0xa>
    23ee:	81 c0       	rjmp	.+258    	; 0x24f2 <free+0x10c>
    23f0:	fc 01       	movw	r30, r24
    23f2:	32 97       	sbiw	r30, 0x02	; 2
    23f4:	13 82       	std	Z+3, r1	; 0x03
    23f6:	12 82       	std	Z+2, r1	; 0x02
    23f8:	a0 91 91 02 	lds	r26, 0x0291	; 0x800291 <__flp>
    23fc:	b0 91 92 02 	lds	r27, 0x0292	; 0x800292 <__flp+0x1>
    2400:	10 97       	sbiw	r26, 0x00	; 0
    2402:	81 f4       	brne	.+32     	; 0x2424 <free+0x3e>
    2404:	20 81       	ld	r18, Z
    2406:	31 81       	ldd	r19, Z+1	; 0x01
    2408:	82 0f       	add	r24, r18
    240a:	93 1f       	adc	r25, r19
    240c:	20 91 8f 02 	lds	r18, 0x028F	; 0x80028f <__brkval>
    2410:	30 91 90 02 	lds	r19, 0x0290	; 0x800290 <__brkval+0x1>
    2414:	28 17       	cp	r18, r24
    2416:	39 07       	cpc	r19, r25
    2418:	51 f5       	brne	.+84     	; 0x246e <free+0x88>
    241a:	f0 93 90 02 	sts	0x0290, r31	; 0x800290 <__brkval+0x1>
    241e:	e0 93 8f 02 	sts	0x028F, r30	; 0x80028f <__brkval>
    2422:	67 c0       	rjmp	.+206    	; 0x24f2 <free+0x10c>
    2424:	ed 01       	movw	r28, r26
    2426:	20 e0       	ldi	r18, 0x00	; 0
    2428:	30 e0       	ldi	r19, 0x00	; 0
    242a:	ce 17       	cp	r28, r30
    242c:	df 07       	cpc	r29, r31
    242e:	40 f4       	brcc	.+16     	; 0x2440 <free+0x5a>
    2430:	4a 81       	ldd	r20, Y+2	; 0x02
    2432:	5b 81       	ldd	r21, Y+3	; 0x03
    2434:	9e 01       	movw	r18, r28
    2436:	41 15       	cp	r20, r1
    2438:	51 05       	cpc	r21, r1
    243a:	f1 f0       	breq	.+60     	; 0x2478 <free+0x92>
    243c:	ea 01       	movw	r28, r20
    243e:	f5 cf       	rjmp	.-22     	; 0x242a <free+0x44>
    2440:	d3 83       	std	Z+3, r29	; 0x03
    2442:	c2 83       	std	Z+2, r28	; 0x02
    2444:	40 81       	ld	r20, Z
    2446:	51 81       	ldd	r21, Z+1	; 0x01
    2448:	84 0f       	add	r24, r20
    244a:	95 1f       	adc	r25, r21
    244c:	c8 17       	cp	r28, r24
    244e:	d9 07       	cpc	r29, r25
    2450:	59 f4       	brne	.+22     	; 0x2468 <free+0x82>
    2452:	88 81       	ld	r24, Y
    2454:	99 81       	ldd	r25, Y+1	; 0x01
    2456:	84 0f       	add	r24, r20
    2458:	95 1f       	adc	r25, r21
    245a:	02 96       	adiw	r24, 0x02	; 2
    245c:	91 83       	std	Z+1, r25	; 0x01
    245e:	80 83       	st	Z, r24
    2460:	8a 81       	ldd	r24, Y+2	; 0x02
    2462:	9b 81       	ldd	r25, Y+3	; 0x03
    2464:	93 83       	std	Z+3, r25	; 0x03
    2466:	82 83       	std	Z+2, r24	; 0x02
    2468:	21 15       	cp	r18, r1
    246a:	31 05       	cpc	r19, r1
    246c:	29 f4       	brne	.+10     	; 0x2478 <free+0x92>
    246e:	f0 93 92 02 	sts	0x0292, r31	; 0x800292 <__flp+0x1>
    2472:	e0 93 91 02 	sts	0x0291, r30	; 0x800291 <__flp>
    2476:	3d c0       	rjmp	.+122    	; 0x24f2 <free+0x10c>
    2478:	e9 01       	movw	r28, r18
    247a:	fb 83       	std	Y+3, r31	; 0x03
    247c:	ea 83       	std	Y+2, r30	; 0x02
    247e:	49 91       	ld	r20, Y+
    2480:	59 91       	ld	r21, Y+
    2482:	c4 0f       	add	r28, r20
    2484:	d5 1f       	adc	r29, r21
    2486:	ec 17       	cp	r30, r28
    2488:	fd 07       	cpc	r31, r29
    248a:	61 f4       	brne	.+24     	; 0x24a4 <free+0xbe>
    248c:	80 81       	ld	r24, Z
    248e:	91 81       	ldd	r25, Z+1	; 0x01
    2490:	84 0f       	add	r24, r20
    2492:	95 1f       	adc	r25, r21
    2494:	02 96       	adiw	r24, 0x02	; 2
    2496:	e9 01       	movw	r28, r18
    2498:	99 83       	std	Y+1, r25	; 0x01
    249a:	88 83       	st	Y, r24
    249c:	82 81       	ldd	r24, Z+2	; 0x02
    249e:	93 81       	ldd	r25, Z+3	; 0x03
    24a0:	9b 83       	std	Y+3, r25	; 0x03
    24a2:	8a 83       	std	Y+2, r24	; 0x02
    24a4:	e0 e0       	ldi	r30, 0x00	; 0
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	12 96       	adiw	r26, 0x02	; 2
    24aa:	8d 91       	ld	r24, X+
    24ac:	9c 91       	ld	r25, X
    24ae:	13 97       	sbiw	r26, 0x03	; 3
    24b0:	00 97       	sbiw	r24, 0x00	; 0
    24b2:	19 f0       	breq	.+6      	; 0x24ba <free+0xd4>
    24b4:	fd 01       	movw	r30, r26
    24b6:	dc 01       	movw	r26, r24
    24b8:	f7 cf       	rjmp	.-18     	; 0x24a8 <free+0xc2>
    24ba:	8d 91       	ld	r24, X+
    24bc:	9c 91       	ld	r25, X
    24be:	11 97       	sbiw	r26, 0x01	; 1
    24c0:	9d 01       	movw	r18, r26
    24c2:	2e 5f       	subi	r18, 0xFE	; 254
    24c4:	3f 4f       	sbci	r19, 0xFF	; 255
    24c6:	82 0f       	add	r24, r18
    24c8:	93 1f       	adc	r25, r19
    24ca:	20 91 8f 02 	lds	r18, 0x028F	; 0x80028f <__brkval>
    24ce:	30 91 90 02 	lds	r19, 0x0290	; 0x800290 <__brkval+0x1>
    24d2:	28 17       	cp	r18, r24
    24d4:	39 07       	cpc	r19, r25
    24d6:	69 f4       	brne	.+26     	; 0x24f2 <free+0x10c>
    24d8:	30 97       	sbiw	r30, 0x00	; 0
    24da:	29 f4       	brne	.+10     	; 0x24e6 <free+0x100>
    24dc:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <__flp+0x1>
    24e0:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <__flp>
    24e4:	02 c0       	rjmp	.+4      	; 0x24ea <free+0x104>
    24e6:	13 82       	std	Z+3, r1	; 0x03
    24e8:	12 82       	std	Z+2, r1	; 0x02
    24ea:	b0 93 90 02 	sts	0x0290, r27	; 0x800290 <__brkval+0x1>
    24ee:	a0 93 8f 02 	sts	0x028F, r26	; 0x80028f <__brkval>
    24f2:	df 91       	pop	r29
    24f4:	cf 91       	pop	r28
    24f6:	08 95       	ret

000024f8 <memcpy>:
    24f8:	fb 01       	movw	r30, r22
    24fa:	dc 01       	movw	r26, r24
    24fc:	02 c0       	rjmp	.+4      	; 0x2502 <memcpy+0xa>
    24fe:	01 90       	ld	r0, Z+
    2500:	0d 92       	st	X+, r0
    2502:	41 50       	subi	r20, 0x01	; 1
    2504:	50 40       	sbci	r21, 0x00	; 0
    2506:	d8 f7       	brcc	.-10     	; 0x24fe <memcpy+0x6>
    2508:	08 95       	ret

0000250a <memset>:
    250a:	dc 01       	movw	r26, r24
    250c:	01 c0       	rjmp	.+2      	; 0x2510 <memset+0x6>
    250e:	6d 93       	st	X+, r22
    2510:	41 50       	subi	r20, 0x01	; 1
    2512:	50 40       	sbci	r21, 0x00	; 0
    2514:	e0 f7       	brcc	.-8      	; 0x250e <memset+0x4>
    2516:	08 95       	ret

00002518 <_exit>:
    2518:	f8 94       	cli

0000251a <__stop_program>:
    251a:	ff cf       	rjmp	.-2      	; 0x251a <__stop_program>
